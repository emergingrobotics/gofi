
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/unifi-go/gofi/auth/auth.go (67.9%)</option>
				
				<option value="file1">github.com/unifi-go/gofi/auth/csrf.go (94.1%)</option>
				
				<option value="file2">github.com/unifi-go/gofi/auth/session.go (100.0%)</option>
				
				<option value="file3">github.com/unifi-go/gofi/batch.go (100.0%)</option>
				
				<option value="file4">github.com/unifi-go/gofi/client_impl.go (55.1%)</option>
				
				<option value="file5">github.com/unifi-go/gofi/errors.go (96.7%)</option>
				
				<option value="file6">github.com/unifi-go/gofi/examples/basic/main.go (0.0%)</option>
				
				<option value="file7">github.com/unifi-go/gofi/examples/concurrent/main.go (0.0%)</option>
				
				<option value="file8">github.com/unifi-go/gofi/examples/crud/main.go (0.0%)</option>
				
				<option value="file9">github.com/unifi-go/gofi/examples/errors/main.go (0.0%)</option>
				
				<option value="file10">github.com/unifi-go/gofi/examples/websocket/main.go (0.0%)</option>
				
				<option value="file11">github.com/unifi-go/gofi/internal/json.go (95.8%)</option>
				
				<option value="file12">github.com/unifi-go/gofi/internal/mac.go (100.0%)</option>
				
				<option value="file13">github.com/unifi-go/gofi/internal/url.go (100.0%)</option>
				
				<option value="file14">github.com/unifi-go/gofi/mock/fixtures.go (76.3%)</option>
				
				<option value="file15">github.com/unifi-go/gofi/mock/handlers_auth.go (79.5%)</option>
				
				<option value="file16">github.com/unifi-go/gofi/mock/handlers_client.go (75.7%)</option>
				
				<option value="file17">github.com/unifi-go/gofi/mock/handlers_device.go (68.6%)</option>
				
				<option value="file18">github.com/unifi-go/gofi/mock/handlers_firewall.go (27.7%)</option>
				
				<option value="file19">github.com/unifi-go/gofi/mock/handlers_network.go (0.0%)</option>
				
				<option value="file20">github.com/unifi-go/gofi/mock/handlers_port.go (60.0%)</option>
				
				<option value="file21">github.com/unifi-go/gofi/mock/handlers_routing.go (76.3%)</option>
				
				<option value="file22">github.com/unifi-go/gofi/mock/handlers_setting.go (57.8%)</option>
				
				<option value="file23">github.com/unifi-go/gofi/mock/handlers_site.go (48.9%)</option>
				
				<option value="file24">github.com/unifi-go/gofi/mock/handlers_system.go (78.1%)</option>
				
				<option value="file25">github.com/unifi-go/gofi/mock/handlers_traffic.go (50.0%)</option>
				
				<option value="file26">github.com/unifi-go/gofi/mock/handlers_user.go (0.0%)</option>
				
				<option value="file27">github.com/unifi-go/gofi/mock/handlers_websocket.go (0.0%)</option>
				
				<option value="file28">github.com/unifi-go/gofi/mock/handlers_wlan.go (69.1%)</option>
				
				<option value="file29">github.com/unifi-go/gofi/mock/options.go (100.0%)</option>
				
				<option value="file30">github.com/unifi-go/gofi/mock/response.go (66.7%)</option>
				
				<option value="file31">github.com/unifi-go/gofi/mock/scenarios.go (100.0%)</option>
				
				<option value="file32">github.com/unifi-go/gofi/mock/server.go (74.3%)</option>
				
				<option value="file33">github.com/unifi-go/gofi/mock/state.go (74.7%)</option>
				
				<option value="file34">github.com/unifi-go/gofi/options.go (76.5%)</option>
				
				<option value="file35">github.com/unifi-go/gofi/services/clientstation.go (82.7%)</option>
				
				<option value="file36">github.com/unifi-go/gofi/services/device.go (79.2%)</option>
				
				<option value="file37">github.com/unifi-go/gofi/services/events.go (0.0%)</option>
				
				<option value="file38">github.com/unifi-go/gofi/services/firewall.go (32.4%)</option>
				
				<option value="file39">github.com/unifi-go/gofi/services/network.go (0.0%)</option>
				
				<option value="file40">github.com/unifi-go/gofi/services/portforward.go (69.6%)</option>
				
				<option value="file41">github.com/unifi-go/gofi/services/portprofile.go (67.2%)</option>
				
				<option value="file42">github.com/unifi-go/gofi/services/routing.go (69.6%)</option>
				
				<option value="file43">github.com/unifi-go/gofi/services/services.go (66.7%)</option>
				
				<option value="file44">github.com/unifi-go/gofi/services/setting.go (67.8%)</option>
				
				<option value="file45">github.com/unifi-go/gofi/services/site.go (53.5%)</option>
				
				<option value="file46">github.com/unifi-go/gofi/services/system.go (63.0%)</option>
				
				<option value="file47">github.com/unifi-go/gofi/services/user.go (37.5%)</option>
				
				<option value="file48">github.com/unifi-go/gofi/services/wlan.go (71.7%)</option>
				
				<option value="file49">github.com/unifi-go/gofi/transport/config.go (100.0%)</option>
				
				<option value="file50">github.com/unifi-go/gofi/transport/request.go (100.0%)</option>
				
				<option value="file51">github.com/unifi-go/gofi/transport/response.go (100.0%)</option>
				
				<option value="file52">github.com/unifi-go/gofi/transport/retry.go (84.8%)</option>
				
				<option value="file53">github.com/unifi-go/gofi/transport/transport.go (87.0%)</option>
				
				<option value="file54">github.com/unifi-go/gofi/types/common.go (96.7%)</option>
				
				<option value="file55">github.com/unifi-go/gofi/types/flex.go (82.8%)</option>
				
				<option value="file56">github.com/unifi-go/gofi/websocket/client.go (91.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/unifi-go/gofi/transport"
)

// Manager manages authentication state.
type Manager interface {
        // Login authenticates with the UniFi controller.
        Login(ctx context.Context) error

        // Logout ends the current session.
        Logout(ctx context.Context) error

        // EnsureAuthenticated ensures there is a valid session, refreshing if needed.
        EnsureAuthenticated(ctx context.Context) error

        // Session returns the current session, or nil if not authenticated.
        Session() *Session

        // IsAuthenticated returns true if there is a valid session.
        IsAuthenticated() bool
}

// manager implements the Manager interface.
type manager struct {
        transport transport.Transport
        username  string
        password  string

        session *Session
        csrf    *CSRFHandler

        mu         sync.RWMutex
        refreshing bool
        refreshCh  chan struct{}
}

// New creates a new authentication manager.
func New(transport transport.Transport, username, password string) Manager <span class="cov8" title="1">{
        return &amp;manager{
                transport: transport,
                username:  username,
                password:  password,
                csrf:      NewCSRFHandler(),
        }
}</span>

// Login authenticates with the UniFi controller.
func (m *manager) Login(ctx context.Context) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Prepare login request
        loginReq := map[string]string{
                "username": m.username,
                "password": m.password,
        }

        // Create HTTP request
        req := transport.NewRequest("POST", "/api/auth/login").
                WithBody(loginReq)

        // Execute login
        resp, err := m.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("login request failed: %w", err)
        }</span>

        // Check response status
        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov8" title="1">{
                return fmt.Errorf("login failed: status %d", resp.StatusCode)
        }</span>

        // Parse response
        <span class="cov8" title="1">var loginResp struct {
                Meta struct {
                        RC string `json:"rc"`
                } `json:"meta"`
        }

        if err := json.Unmarshal(resp.Body, &amp;loginResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse login response: %w", err)
        }</span>

        <span class="cov8" title="1">if loginResp.Meta.RC != "ok" </span><span class="cov0" title="0">{
                return fmt.Errorf("login failed: rc=%s", loginResp.Meta.RC)
        }</span>

        // Extract CSRF token from response headers
        <span class="cov8" title="1">csrfToken := resp.Headers.Get("X-CSRF-Token")
        if csrfToken != "" </span><span class="cov8" title="1">{
                m.csrf.Set(csrfToken)
                m.transport.SetCSRFToken(csrfToken)
        }</span>

        // Create session
        <span class="cov8" title="1">m.session = &amp;Session{
                Token:      "authenticated", // Cookie-based, actual token is in transport
                CSRFToken:  csrfToken,
                ExpiresAt:  time.Now().Add(24 * time.Hour), // Default 24h expiration
                Username:   m.username,
                CreatedAt:  time.Now(),
        }

        return nil</span>
}

// Logout ends the current session.
func (m *manager) Logout(ctx context.Context) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.session == nil </span><span class="cov0" title="0">{
                return nil // Already logged out
        }</span>

        // Create logout request
        <span class="cov8" title="1">req := transport.NewRequest("POST", "/api/logout")

        // Execute logout (ignore errors, we're clearing session anyway)
        _, _ = m.transport.Do(ctx, req)

        // Clear session
        m.session = nil
        m.csrf.Set("")
        m.transport.SetCSRFToken("")

        return nil</span>
}

// EnsureAuthenticated ensures there is a valid session, refreshing if needed.
func (m *manager) EnsureAuthenticated(ctx context.Context) error <span class="cov8" title="1">{
        // Quick check without lock
        m.mu.RLock()
        session := m.session
        refreshing := m.refreshing
        refreshCh := m.refreshCh
        m.mu.RUnlock()

        // If valid session and not needing refresh, we're done
        if session != nil &amp;&amp; session.IsValid() &amp;&amp; !session.NeedsRefresh() </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If another goroutine is already refreshing, wait for it
        <span class="cov8" title="1">if refreshing &amp;&amp; refreshCh != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-refreshCh:<span class="cov0" title="0">
                        // Refresh complete, check if we have a valid session now
                        m.mu.RLock()
                        session := m.session
                        m.mu.RUnlock()

                        if session == nil || !session.IsValid() </span><span class="cov0" title="0">{
                                return fmt.Errorf("session refresh failed")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }

        // We need to authenticate/refresh
        <span class="cov8" title="1">m.mu.Lock()

        // Double-check after acquiring lock
        if m.session != nil &amp;&amp; m.session.IsValid() &amp;&amp; !m.session.NeedsRefresh() </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return nil
        }</span>

        // Set up refresh coordination
        <span class="cov8" title="1">if m.refreshing </span><span class="cov0" title="0">{
                // Another goroutine started refreshing between our checks
                refreshCh := m.refreshCh
                m.mu.Unlock()

                if refreshCh != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-refreshCh:<span class="cov0" title="0">
                                m.mu.RLock()
                                session := m.session
                                m.mu.RUnlock()

                                if session == nil || !session.IsValid() </span><span class="cov0" title="0">{
                                        return fmt.Errorf("session refresh failed")
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                }

                // Fall through to retry
                <span class="cov0" title="0">return m.EnsureAuthenticated(ctx)</span>
        }

        // We're the refreshing goroutine
        <span class="cov8" title="1">m.refreshing = true
        m.refreshCh = make(chan struct{})
        refreshCh = m.refreshCh

        m.mu.Unlock()

        // Perform authentication
        err := m.Login(ctx)

        // Clean up refresh state and notify waiters
        m.mu.Lock()
        m.refreshing = false
        close(refreshCh)
        m.refreshCh = nil
        m.mu.Unlock()

        return err</span>
}

// Session returns the current session.
func (m *manager) Session() *Session <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.session
}</span>

// IsAuthenticated returns true if there is a valid session.
func (m *manager) IsAuthenticated() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.session != nil &amp;&amp; m.session.IsValid()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "net/http"
        "sync/atomic"
)

// CSRFHandler handles CSRF token storage and updates.
type CSRFHandler struct {
        token atomic.Value // stores string
}

// NewCSRFHandler creates a new CSRFHandler.
func NewCSRFHandler() *CSRFHandler <span class="cov8" title="1">{
        h := &amp;CSRFHandler{}
        h.token.Store("")
        return h
}</span>

// Get returns the current CSRF token.
func (c *CSRFHandler) Get() string <span class="cov8" title="1">{
        if val := c.token.Load(); val != nil </span><span class="cov8" title="1">{
                if token, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return token
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Set sets the CSRF token.
func (c *CSRFHandler) Set(token string) <span class="cov8" title="1">{
        c.token.Store(token)
}</span>

// UpdateFromResponse updates the CSRF token from an HTTP response.
func (c *CSRFHandler) UpdateFromResponse(resp *http.Response) <span class="cov8" title="1">{
        if resp == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Check for CSRF token in headers
        <span class="cov8" title="1">if token := resp.Header.Get("X-CSRF-Token"); token != "" </span><span class="cov8" title="1">{
                c.Set(token)
                return
        }</span>

        // Also check cookies for CSRF token
        <span class="cov8" title="1">for _, cookie := range resp.Cookies() </span><span class="cov8" title="1">{
                if cookie.Name == "csrf_token" || cookie.Name == "X-CSRF-Token" </span><span class="cov8" title="1">{
                        c.Set(cookie.Value)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import "time"

// Session represents an authenticated session.
type Session struct {
        // Token is the session token/cookie value.
        Token string

        // CSRFToken is the CSRF token for the session.
        CSRFToken string

        // ExpiresAt is the time when the session expires.
        ExpiresAt time.Time

        // Username is the authenticated username.
        Username string

        // CreatedAt is when the session was created.
        CreatedAt time.Time
}

// IsValid returns true if the session is still valid.
func (s *Session) IsValid() bool <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if session has expired
        <span class="cov8" title="1">if !s.ExpiresAt.IsZero() &amp;&amp; time.Now().After(s.ExpiresAt) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Session must have a token
        <span class="cov8" title="1">return s.Token != ""</span>
}

// NeedsRefresh returns true if the session is getting close to expiration.
// Returns true if less than 10 minutes remaining.
func (s *Session) NeedsRefresh() bool <span class="cov8" title="1">{
        if s == nil || s.ExpiresAt.IsZero() </span><span class="cov8" title="1">{
                return false
        }</span>

        // Refresh if less than 10 minutes remaining
        <span class="cov8" title="1">refreshThreshold := time.Now().Add(10 * time.Minute)
        return s.ExpiresAt.Before(refreshThreshold)</span>
}

// Age returns how long the session has been active.
func (s *Session) Age() time.Duration <span class="cov8" title="1">{
        if s == nil || s.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return time.Since(s.CreatedAt)</span>
}

// TimeUntilExpiry returns how much time is left before the session expires.
func (s *Session) TimeUntilExpiry() time.Duration <span class="cov8" title="1">{
        if s == nil || s.ExpiresAt.IsZero() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return time.Until(s.ExpiresAt)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package gofi

import (
        "context"
        "sync"
)

// BatchResult represents the result of a batch operation.
type BatchResult[T any] struct {
        // Item is the result item (nil if error occurred).
        Item *T

        // Error is the error that occurred (nil if successful).
        Error error

        // Index is the index of this item in the original batch.
        Index int
}

// BatchGet performs concurrent Get operations and returns results.
// The getter function is called for each ID concurrently.
func BatchGet[T any](
        ctx context.Context,
        ids []string,
        getter func(ctx context.Context, id string) (*T, error),
) []BatchResult[T] <span class="cov8" title="1">{
        results := make([]BatchResult[T], len(ids))
        var wg sync.WaitGroup

        for i, id := range ids </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, itemID string) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        item, err := getter(ctx, itemID)
                        results[idx] = BatchResult[T]{
                                Item:  item,
                                Error: err,
                                Index: idx,
                        }
                }</span>(i, id)
        }

        <span class="cov8" title="1">wg.Wait()
        return results</span>
}

// BatchCreate performs concurrent Create operations and returns results.
// The creator function is called for each item concurrently.
func BatchCreate[T any](
        ctx context.Context,
        items []*T,
        creator func(ctx context.Context, item *T) (*T, error),
) []BatchResult[T] <span class="cov8" title="1">{
        results := make([]BatchResult[T], len(items))
        var wg sync.WaitGroup

        for i, item := range items </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, createItem *T) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        created, err := creator(ctx, createItem)
                        results[idx] = BatchResult[T]{
                                Item:  created,
                                Error: err,
                                Index: idx,
                        }
                }</span>(i, item)
        }

        <span class="cov8" title="1">wg.Wait()
        return results</span>
}

// BatchDelete performs concurrent Delete operations and returns errors.
// The deleter function is called for each ID concurrently.
func BatchDelete(
        ctx context.Context,
        ids []string,
        deleter func(ctx context.Context, id string) error,
) []error <span class="cov8" title="1">{
        errors := make([]error, len(ids))
        var wg sync.WaitGroup

        for i, id := range ids </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, itemID string) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        errors[idx] = deleter(ctx, itemID)
                }</span>(i, id)
        }

        <span class="cov8" title="1">wg.Wait()
        return errors</span>
}

// BatchUpdate performs concurrent Update operations and returns results.
func BatchUpdate[T any](
        ctx context.Context,
        items []*T,
        updater func(ctx context.Context, item *T) (*T, error),
) []BatchResult[T] <span class="cov8" title="1">{
        results := make([]BatchResult[T], len(items))
        var wg sync.WaitGroup

        for i, item := range items </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, updateItem *T) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        updated, err := updater(ctx, updateItem)
                        results[idx] = BatchResult[T]{
                                Item:  updated,
                                Error: err,
                                Index: idx,
                        }
                }</span>(i, item)
        }

        <span class="cov8" title="1">wg.Wait()
        return results</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gofi

import (
        "context"
        "crypto/tls"
        "fmt"
        "net"
        "net/url"
        "strconv"
        "sync"
        "sync/atomic"

        "github.com/unifi-go/gofi/auth"
        "github.com/unifi-go/gofi/services"
        "github.com/unifi-go/gofi/transport"
)

// client implements the Client interface.
type client struct {
        config    *Config
        transport transport.Transport
        auth      auth.Manager
        connected atomic.Bool

        // Lazy-initialized services
        mu                  sync.Mutex
        sitesService        services.SiteService
        devicesService      services.DeviceService
        networksService     services.NetworkService
        wlansService        services.WLANService
        firewallService     services.FirewallService
        clientsService      services.ClientService
        usersService        services.UserService
        routingService      services.RoutingService
        portForwardService  services.PortForwardService
        portProfileService  services.PortProfileService
        settingService      services.SettingService
        systemService       services.SystemService
        // Other services will be added in later phases

        logger Logger
}

// New creates a new UniFi client.
func New(config *Config, opts ...Option) (Client, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidConfig
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if config.Host == "" </span><span class="cov8" title="1">{
                return nil, NewValidationError("Host", "required")
        }</span>

        <span class="cov8" title="1">if config.Username == "" </span><span class="cov8" title="1">{
                return nil, NewValidationError("Username", "required")
        }</span>

        <span class="cov8" title="1">if config.Password == "" </span><span class="cov8" title="1">{
                return nil, NewValidationError("Password", "required")
        }</span>

        // Apply defaults
        <span class="cov8" title="1">if config.Port == 0 </span><span class="cov8" title="1">{
                config.Port = 443
        }</span>

        <span class="cov8" title="1">if config.Site == "" </span><span class="cov8" title="1">{
                config.Site = "default"
        }</span>

        <span class="cov8" title="1">if config.Timeout == 0 </span><span class="cov8" title="1">{
                config.Timeout = 30 * transport.DefaultConfig("").Timeout
        }</span>

        <span class="cov8" title="1">if config.MaxIdleConns == 0 </span><span class="cov8" title="1">{
                config.MaxIdleConns = 10
        }</span>

        // Apply options
        <span class="cov8" title="1">for _, opt := range opts </span><span class="cov8" title="1">{
                opt(config)
        }</span>

        // Build base URL
        <span class="cov8" title="1">baseURL := &amp;url.URL{
                Scheme: "https",
                Host:   net.JoinHostPort(config.Host, strconv.Itoa(config.Port)),
        }

        // Create transport config
        transportConfig := transport.DefaultConfig(baseURL.String())
        transportConfig.Timeout = config.Timeout
        transportConfig.MaxIdleConns = config.MaxIdleConns
        transportConfig.TLSConfig = config.TLSConfig

        // Apply TLS skip verify if configured
        if config.SkipTLSVerify </span><span class="cov8" title="1">{
                if transportConfig.TLSConfig == nil </span><span class="cov8" title="1">{
                        transportConfig.TLSConfig = &amp;tls.Config{}
                }</span>
                <span class="cov8" title="1">transportConfig.TLSConfig.InsecureSkipVerify = true</span>
        }

        // Create transport with retry wrapper
        <span class="cov8" title="1">baseTransport, err := transport.New(transportConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create transport: %w", err)
        }</span>

        // Wrap with retry if configured
        <span class="cov8" title="1">var trans transport.Transport
        if config.RetryConfig != nil </span><span class="cov0" title="0">{
                retryConfig := &amp;transport.RetryConfig{
                        MaxRetries:     config.RetryConfig.MaxRetries,
                        InitialBackoff: config.RetryConfig.InitialBackoff,
                        MaxBackoff:     config.RetryConfig.MaxBackoff,
                }
                trans = transport.NewRetryTransport(baseTransport, retryConfig)
        }</span> else<span class="cov8" title="1"> {
                trans = baseTransport
        }</span>

        // Create auth manager
        <span class="cov8" title="1">authMgr := auth.New(trans, config.Username, config.Password)

        c := &amp;client{
                config:    config,
                transport: trans,
                auth:      authMgr,
                logger:    config.Logger,
        }

        return c, nil</span>
}

// Connect establishes a connection to the UniFi controller.
func (c *client) Connect(ctx context.Context) error <span class="cov8" title="1">{
        if c.connected.Load() </span><span class="cov8" title="1">{
                return ErrAlreadyConnected
        }</span>

        // Perform authentication
        <span class="cov8" title="1">if err := c.auth.Login(ctx); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("authentication failed: %w", err)
        }</span>

        <span class="cov8" title="1">c.connected.Store(true)

        if c.logger != nil </span><span class="cov0" title="0">{
                c.logger.Info("Connected to UniFi controller", "host", c.config.Host)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Disconnect closes the connection to the UniFi controller.
func (c *client) Disconnect(ctx context.Context) error <span class="cov8" title="1">{
        if !c.connected.Load() </span><span class="cov8" title="1">{
                return nil // Already disconnected
        }</span>

        // Logout
        <span class="cov8" title="1">if err := c.auth.Logout(ctx); err != nil </span><span class="cov0" title="0">{
                if c.logger != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Logout failed", "error", err)
                }</span>
                // Don't fail disconnect on logout error
        }

        <span class="cov8" title="1">c.connected.Store(false)
        c.transport.Close()

        if c.logger != nil </span><span class="cov0" title="0">{
                c.logger.Info("Disconnected from UniFi controller")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsConnected returns true if the client is connected.
func (c *client) IsConnected() bool <span class="cov8" title="1">{
        return c.connected.Load() &amp;&amp; c.auth.IsAuthenticated()
}</span>

// Sites returns the site service.
func (c *client) Sites() services.SiteService <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.sitesService == nil </span><span class="cov8" title="1">{
                c.sitesService = services.NewSiteService(c.transport)
        }</span>

        <span class="cov8" title="1">return c.sitesService</span>
}

// Devices returns the device service.
func (c *client) Devices() services.DeviceService <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.devicesService == nil </span><span class="cov8" title="1">{
                c.devicesService = services.NewDeviceService(c.transport)
        }</span>

        <span class="cov8" title="1">return c.devicesService</span>
}

// Networks returns the network service.
func (c *client) Networks() services.NetworkService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.networksService == nil </span><span class="cov0" title="0">{
                c.networksService = services.NewNetworkService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.networksService</span>
}

// WLANs returns the WLAN service.
func (c *client) WLANs() services.WLANService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.wlansService == nil </span><span class="cov0" title="0">{
                c.wlansService = services.NewWLANService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.wlansService</span>
}

// Firewall returns the firewall service.
func (c *client) Firewall() services.FirewallService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.firewallService == nil </span><span class="cov0" title="0">{
                c.firewallService = services.NewFirewallService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.firewallService</span>
}

// Clients returns the client service.
func (c *client) Clients() services.ClientService <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.clientsService == nil </span><span class="cov8" title="1">{
                c.clientsService = services.NewClientService(c.transport)
        }</span>

        <span class="cov8" title="1">return c.clientsService</span>
}

// Users returns the user service.
func (c *client) Users() services.UserService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.usersService == nil </span><span class="cov0" title="0">{
                c.usersService = services.NewUserService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.usersService</span>
}

// Routing returns the routing service.
func (c *client) Routing() services.RoutingService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.routingService == nil </span><span class="cov0" title="0">{
                c.routingService = services.NewRoutingService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.routingService</span>
}

// PortForwards returns the port forward service.
func (c *client) PortForwards() services.PortForwardService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.portForwardService == nil </span><span class="cov0" title="0">{
                c.portForwardService = services.NewPortForwardService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.portForwardService</span>
}

// PortProfiles returns the port profile service.
func (c *client) PortProfiles() services.PortProfileService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.portProfileService == nil </span><span class="cov0" title="0">{
                c.portProfileService = services.NewPortProfileService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.portProfileService</span>
}

// Settings returns the settings service.
func (c *client) Settings() services.SettingService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.settingService == nil </span><span class="cov0" title="0">{
                c.settingService = services.NewSettingService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.settingService</span>
}

// System returns the system service.
func (c *client) System() services.SystemService <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.systemService == nil </span><span class="cov0" title="0">{
                c.systemService = services.NewSystemService(c.transport)
        }</span>

        <span class="cov0" title="0">return c.systemService</span>
}

// Events returns the event service.
func (c *client) Events() services.EventService <span class="cov0" title="0">{
        return nil // Implemented in Phase 18
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package gofi

import (
        "errors"
        "fmt"
)

// Sentinel errors for common error conditions.
var (
        // ErrNotConnected is returned when an operation requires a connection but the client is not connected.
        ErrNotConnected = errors.New("not connected to UniFi controller")

        // ErrAlreadyConnected is returned when Connect() is called but the client is already connected.
        ErrAlreadyConnected = errors.New("already connected to UniFi controller")

        // ErrAuthenticationFailed is returned when login credentials are invalid.
        ErrAuthenticationFailed = errors.New("authentication failed: invalid credentials")

        // ErrSessionExpired is returned when the session token has expired.
        ErrSessionExpired = errors.New("session expired")

        // ErrInvalidCSRFToken is returned when the CSRF token is invalid or missing.
        ErrInvalidCSRFToken = errors.New("invalid or missing CSRF token")

        // ErrNotFound is returned when a requested resource is not found.
        ErrNotFound = errors.New("resource not found")

        // ErrPermissionDenied is returned when the user lacks permission for an operation.
        ErrPermissionDenied = errors.New("permission denied")

        // ErrAlreadyExists is returned when attempting to create a resource that already exists.
        ErrAlreadyExists = errors.New("resource already exists")

        // ErrInvalidRequest is returned when the request is malformed or invalid.
        ErrInvalidRequest = errors.New("invalid request")

        // ErrRateLimited is returned when too many requests have been made.
        ErrRateLimited = errors.New("rate limited: too many requests")

        // ErrServerError is returned when the server encounters an internal error.
        ErrServerError = errors.New("server error")

        // ErrTimeout is returned when an operation times out.
        ErrTimeout = errors.New("operation timed out")

        // ErrInvalidConfig is returned when the configuration is invalid.
        ErrInvalidConfig = errors.New("invalid configuration")
)

// APIError represents an error returned by the UniFi API.
type APIError struct {
        // StatusCode is the HTTP status code.
        StatusCode int

        // RC is the UniFi response code (e.g., "error", "ok").
        RC string

        // Message is the error message from the API.
        Message string

        // Endpoint is the API endpoint that returned the error.
        Endpoint string

        // Err is the underlying sentinel error, if any.
        Err error
}

// Error implements the error interface.
func (e *APIError) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("API error [%d]: %s (rc=%s, endpoint=%s)", e.StatusCode, e.Message, e.RC, e.Endpoint)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("API error [%d]: rc=%s, endpoint=%s", e.StatusCode, e.RC, e.Endpoint)</span>
}

// Is implements error comparison for errors.Is().
func (e *APIError) Is(target error) bool <span class="cov8" title="1">{
        if e.Err != nil &amp;&amp; errors.Is(e.Err, target) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check if target is an APIError with matching properties
        <span class="cov8" title="1">if apiErr, ok := target.(*APIError); ok </span><span class="cov8" title="1">{
                if apiErr.StatusCode != 0 &amp;&amp; apiErr.StatusCode != e.StatusCode </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">if apiErr.RC != "" &amp;&amp; apiErr.RC != e.RC </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">return true</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Unwrap returns the underlying error.
func (e *APIError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewAPIError creates a new APIError with the given parameters.
func NewAPIError(statusCode int, rc, message, endpoint string) *APIError <span class="cov8" title="1">{
        err := &amp;APIError{
                StatusCode: statusCode,
                RC:         rc,
                Message:    message,
                Endpoint:   endpoint,
        }

        // Map to sentinel errors based on status code and RC
        switch statusCode </span>{
        case 401:<span class="cov8" title="1">
                err.Err = ErrAuthenticationFailed</span>
        case 403:<span class="cov8" title="1">
                if rc == "error_invalid_csrf_token" </span><span class="cov8" title="1">{
                        err.Err = ErrInvalidCSRFToken
                }</span> else<span class="cov8" title="1"> {
                        err.Err = ErrPermissionDenied
                }</span>
        case 404:<span class="cov8" title="1">
                err.Err = ErrNotFound</span>
        case 409:<span class="cov8" title="1">
                err.Err = ErrAlreadyExists</span>
        case 429:<span class="cov8" title="1">
                err.Err = ErrRateLimited</span>
        case 500, 502, 503, 504:<span class="cov8" title="1">
                err.Err = ErrServerError</span>
        default:<span class="cov8" title="1">
                if rc == "error" || rc == "error_invalid" </span><span class="cov8" title="1">{
                        err.Err = ErrInvalidRequest
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// ValidationError represents a validation error for input data.
type ValidationError struct {
        // Field is the name of the field that failed validation.
        Field string

        // Message is the validation error message.
        Message string
}

// Error implements the error interface.
func (e *ValidationError) Error() string <span class="cov8" title="1">{
        if e.Field != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("validation error: %s: %s", e.Field, e.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("validation error: %s", e.Message)</span>
}

// NewValidationError creates a new ValidationError.
func NewValidationError(field, message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Field:   field,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "fmt"
        "log"

        "github.com/unifi-go/gofi"
)

func main() <span class="cov0" title="0">{
        // Create client configuration
        config := &amp;gofi.Config{
                Host:     "192.168.1.1", // Your UDM Pro IP
                Port:     443,
                Username: "admin",
                Password: "your-password",

                // For self-signed certificates (dev/testing only)
                SkipTLSVerify: true,
        }

        // Create client
        client, err := gofi.New(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        // Connect to controller
        <span class="cov0" title="0">ctx := context.Background()
        if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect(ctx)

        fmt.Println("Connected to UniFi controller!")

        // List all sites
        sites, err := client.Sites().List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list sites: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nFound %d site(s):\n", len(sites))
        for _, site := range sites </span><span class="cov0" title="0">{
                fmt.Printf("  - %s (%s)\n", site.Desc, site.Name)
        }</span>

        // List devices on default site
        <span class="cov0" title="0">devices, err := client.Devices().List(ctx, "default")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list devices: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nFound %d device(s):\n", len(devices))
        for _, device := range devices </span><span class="cov0" title="0">{
                fmt.Printf("  - %s (%s) - %s - State: %s\n",
                        device.Name,
                        device.Model,
                        device.MAC,
                        device.State.String(),
                )
        }</span>

        // List networks
        <span class="cov0" title="0">networks, err := client.Networks().List(ctx, "default")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list networks: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nFound %d network(s):\n", len(networks))
        for _, network := range networks </span><span class="cov0" title="0">{
                fmt.Printf("  - %s (VLAN Enabled: %t)\n", network.Name, network.VLANEnabled)
        }</span>

        // Get health information
        <span class="cov0" title="0">health, err := client.Sites().Health(ctx, "default")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get health: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nHealth Status:\n")
        for _, h := range health </span><span class="cov0" title="0">{
                fmt.Printf("  - %s: %s\n", h.Subsystem, h.Status)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "fmt"
        "log"

        "github.com/unifi-go/gofi"
        "github.com/unifi-go/gofi/types"
)

func main() <span class="cov0" title="0">{
        // Create client
        config := &amp;gofi.Config{
                Host:          "192.168.1.1",
                Username:      "admin",
                Password:      "your-password",
                SkipTLSVerify: true,
        }

        client, err := gofi.New(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect(ctx)

        site := "default"

        // List all devices to get their IDs
        devices, err := client.Devices().List(ctx, site)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list devices: %v", err)
        }</span>

        <span class="cov0" title="0">if len(devices) == 0 </span><span class="cov0" title="0">{
                log.Fatal("No devices found for batch operations demo")
        }</span>

        // Extract device IDs
        <span class="cov0" title="0">deviceIDs := make([]string, 0, len(devices))
        for _, device := range devices </span><span class="cov0" title="0">{
                deviceIDs = append(deviceIDs, device.ID)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Fetching %d devices concurrently...\n", len(deviceIDs))

        // Batch get devices
        results := gofi.BatchGet(ctx, deviceIDs, func(ctx context.Context, id string) (*types.Device, error) </span><span class="cov0" title="0">{
                return client.Devices().Get(ctx, site, id)
        }</span>)

        // Process results
        <span class="cov0" title="0">successCount := 0
        errorCount := 0

        for _, result := range results </span><span class="cov0" title="0">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        errorCount++
                        fmt.Printf("  [ERROR] Index %d: %v\n", result.Index, result.Error)
                }</span> else<span class="cov0" title="0"> {
                        successCount++
                        fmt.Printf("  [OK] %s (%s)\n", result.Item.Name, result.Item.MAC)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nBatch operation complete: %d successful, %d errors\n", successCount, errorCount)

        // Demonstrate concurrent device commands
        if len(devices) &gt; 0 &amp;&amp; devices[0].MAC != "" </span><span class="cov0" title="0">{
                fmt.Println("\nExample: Concurrent device operations (commented out for safety)")
                fmt.Println("// To locate multiple devices:")
                fmt.Println("// macs := []string{\"aa:bb:cc:dd:ee:f1\", \"aa:bb:cc:dd:ee:f2\"}")
                fmt.Println("// errors := gofi.BatchDelete(ctx, macs, func(ctx context.Context, mac string) error {")
                fmt.Println("//     return client.Devices().Locate(ctx, site, mac)")
                fmt.Println("// })")
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "context"
        "fmt"
        "log"

        "github.com/unifi-go/gofi"
        "github.com/unifi-go/gofi/types"
)

func main() <span class="cov0" title="0">{
        // Create client
        config := &amp;gofi.Config{
                Host:          "192.168.1.1",
                Username:      "admin",
                Password:      "your-password",
                SkipTLSVerify: true,
        }

        client, err := gofi.New(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect(ctx)

        site := "default"

        // Create a new network
        fmt.Println("Creating new network...")
        network := &amp;types.Network{
                Name:        "IoT Network",
                Purpose:     "corporate",
                VLANEnabled: true,
                VLAN:        20,
                IPSubnet:    "192.168.20.1/24",
                DHCPDEnabled: true,
                DHCPDStart:  "192.168.20.10",
                DHCPDStop:   "192.168.20.250",
        }

        created, err := client.Networks().Create(ctx, site, network)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create network: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Created network: %s (ID: %s)\n", created.Name, created.ID)

        // Create a new WLAN
        fmt.Println("\nCreating new WLAN...")
        wlan := &amp;types.WLAN{
                Name:       "Guest WiFi",
                Enabled:    true,
                Security:   "wpapsk",
                WPAMode:    "wpa2",
                WPAEnc:     "ccmp",
                Passphrase: "guestpassword123",
                // NetworkID: created.ID, // Link to network (if field exists)
                IsGuest:    true,
        }

        createdWLAN, err := client.WLANs().Create(ctx, site, wlan)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WLAN: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Created WLAN: %s (ID: %s)\n", createdWLAN.Name, createdWLAN.ID)

        // Update the WLAN
        fmt.Println("\nUpdating WLAN...")
        createdWLAN.Name = "Guest WiFi (Updated)"

        updated, err := client.WLANs().Update(ctx, site, createdWLAN)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to update WLAN: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Updated WLAN name to: %s\n", updated.Name)

        // List all WLANs
        fmt.Println("\nListing all WLANs...")
        wlans, err := client.WLANs().List(ctx, site)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list WLANs: %v", err)
        }</span>

        <span class="cov0" title="0">for _, w := range wlans </span><span class="cov0" title="0">{
                fmt.Printf("  - %s (Security: %s, Enabled: %t)\n", w.Name, w.Security, w.Enabled)
        }</span>

        // Cleanup: Delete the WLAN and network
        <span class="cov0" title="0">fmt.Println("\nCleaning up...")

        if err := client.WLANs().Delete(ctx, site, createdWLAN.ID); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to delete WLAN: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Deleted WLAN")
        }</span>

        <span class="cov0" title="0">if err := client.Networks().Delete(ctx, site, created.ID); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to delete network: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Deleted network")
        }</span>

        <span class="cov0" title="0">fmt.Println("\nDone!")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "log"

        "github.com/unifi-go/gofi"
)

func main() <span class="cov0" title="0">{
        config := &amp;gofi.Config{
                Host:          "192.168.1.1",
                Username:      "admin",
                Password:      "your-password",
                SkipTLSVerify: true,
        }

        client, err := gofi.New(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Example 1: Connection errors
        fmt.Println("=== Example 1: Handling connection errors ===")
        if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                // Check for specific error types
                if errors.Is(err, gofi.ErrAuthenticationFailed) </span><span class="cov0" title="0">{
                        fmt.Println("Authentication failed - check credentials")
                        return
                }</span>

                <span class="cov0" title="0">if errors.Is(err, gofi.ErrTimeout) </span><span class="cov0" title="0">{
                        fmt.Println("Connection timed out - check network")
                        return
                }</span>

                <span class="cov0" title="0">fmt.Printf("Connection error: %v\n", err)
                return</span>
        }
        <span class="cov0" title="0">defer client.Disconnect(ctx)

        fmt.Println("Connected successfully!")

        // Example 2: Resource not found
        fmt.Println("\n=== Example 2: Handling not found errors ===")
        _, err = client.Devices().Get(ctx, "default", "nonexistent-id")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gofi.ErrNotFound) </span><span class="cov0" title="0">{
                        fmt.Println("Device not found (expected)")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Unexpected error: %v\n", err)
                }</span>
        }

        // Example 3: API errors
        <span class="cov0" title="0">fmt.Println("\n=== Example 3: Handling API errors ===")
        _, err = client.Networks().Get(ctx, "default", "invalid-id")
        if err != nil </span><span class="cov0" title="0">{
                var apiErr *gofi.APIError
                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                        fmt.Printf("API Error [%d]: %s (endpoint: %s)\n",
                                apiErr.StatusCode,
                                apiErr.Message,
                                apiErr.Endpoint,
                        )
                }</span>
        }

        // Example 4: Validation errors
        <span class="cov0" title="0">fmt.Println("\n=== Example 4: Handling validation errors ===")
        invalidConfig := &amp;gofi.Config{
                // Missing required fields
                Username: "admin",
        }

        _, err = gofi.New(invalidConfig)
        if err != nil </span><span class="cov0" title="0">{
                var valErr *gofi.ValidationError
                if errors.As(err, &amp;valErr) </span><span class="cov0" title="0">{
                        fmt.Printf("Validation error on field '%s': %s\n", valErr.Field, valErr.Message)
                }</span>
        }

        // Example 5: Retry on transient failures
        <span class="cov0" title="0">fmt.Println("\n=== Example 5: Automatic retry on transient failures ===")
        retryConfig := &amp;gofi.Config{
                Host:          "192.168.1.1",
                Username:      "admin",
                Password:      "your-password",
                SkipTLSVerify: true,
                RetryConfig: &amp;gofi.RetryConfig{
                        MaxRetries:     3,
                        InitialBackoff: 100,
                        MaxBackoff:     5000,
                },
        }

        retryClient, _ := gofi.New(retryConfig)
        if err := retryClient.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                // Connection will be retried automatically on transient failures
                fmt.Printf("Connection failed after retries: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Connected with retry configuration")
                retryClient.Disconnect(ctx)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n=== Error handling examples complete ===")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/unifi-go/gofi"
)

func main() <span class="cov0" title="0">{
        // Create client
        config := &amp;gofi.Config{
                Host:          "192.168.1.1",
                Username:      "admin",
                Password:      "your-password",
                SkipTLSVerify: true,
        }

        client, err := gofi.New(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect(ctx)

        fmt.Println("Connected! Subscribing to events...")

        // Subscribe to events
        eventCh, errorCh, err := client.Events().Subscribe(ctx, "default")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to subscribe to events: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Events().Close()

        fmt.Println("Listening for events... Press Ctrl+C to exit")

        // Handle graceful shutdown
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)

        // Process events
        for </span><span class="cov0" title="0">{
                select </span>{
                case event, ok := &lt;-eventCh:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                fmt.Println("Event channel closed")
                                return
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("[EVENT] %s: %s\n", event.Key, event.Message)

                        // Print additional details based on event type
                        switch event.Key </span>{
                        case "EVT_WU_Connected", "EVT_WU_Disconnected":<span class="cov0" title="0">
                                fmt.Printf("        Client: %s, SSID: %s\n", event.Client, event.SSID)</span>
                        case "EVT_AP_Connected", "EVT_AP_Disconnected":<span class="cov0" title="0">
                                fmt.Printf("        AP: %s (%s)\n", event.APName, event.APMAC)</span>
                        }

                case err, ok := &lt;-errorCh:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                fmt.Println("Error channel closed")
                                return
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("[ERROR] %v\n", err)</span>

                case &lt;-sigCh:<span class="cov0" title="0">
                        fmt.Println("\nShutting down gracefully...")
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package internal

import (
        "encoding/json"
        "fmt"

        "github.com/unifi-go/gofi/types"
)

// ParseAPIResponse parses a UniFi API response into the generic APIResponse type.
func ParseAPIResponse[T any](data []byte) (*types.APIResponse[T], error) <span class="cov8" title="1">{
        var resp types.APIResponse[T]
        if err := json.Unmarshal(data, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse API response: %w", err)
        }</span>

        // Check if the response indicates an error
        <span class="cov8" title="1">if resp.Meta.RC != "ok" &amp;&amp; resp.Meta.RC != "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API error: %s (rc=%s)", resp.Meta.Message, resp.Meta.RC)
        }</span>

        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// IsErrorResponse checks if the response data indicates an error.
func IsErrorResponse(data []byte) bool <span class="cov8" title="1">{
        var meta struct {
                Meta types.ResponseMeta `json:"meta"`
        }

        if err := json.Unmarshal(data, &amp;meta); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return meta.Meta.RC != "" &amp;&amp; meta.Meta.RC != "ok"</span>
}

// ExtractErrorMessage extracts the error message from an API error response.
func ExtractErrorMessage(data []byte) string <span class="cov8" title="1">{
        var meta struct {
                Meta types.ResponseMeta `json:"meta"`
        }

        if err := json.Unmarshal(data, &amp;meta); err != nil </span><span class="cov8" title="1">{
                return "unknown error"
        }</span>

        <span class="cov8" title="1">if meta.Meta.Message != "" </span><span class="cov8" title="1">{
                return meta.Meta.Message
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("error (rc=%s)", meta.Meta.RC)</span>
}

// ParseSingleResult parses an API response that contains a single item.
// If the response contains multiple items, returns the first one.
func ParseSingleResult[T any](data []byte) (*T, error) <span class="cov8" title="1">{
        resp, err := ParseAPIResponse[T](data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(resp.Data) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no data in response")
        }</span>

        <span class="cov8" title="1">return &amp;resp.Data[0], nil</span>
}

// MarshalCommand marshals a command request with the given command name and MAC.
func MarshalCommand(cmd, mac string) ([]byte, error) <span class="cov8" title="1">{
        cmdReq := types.CommandRequest{
                Cmd: cmd,
                MAC: mac,
        }
        return json.Marshal(cmdReq)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package internal

import (
        "regexp"
        "strings"
)

var macRegex = regexp.MustCompile(`^([0-9a-fA-F]{2}[:-]?){5}([0-9a-fA-F]{2})$`)

// NormalizeMAC normalizes a MAC address to lowercase without separators.
// Example: "AA:BB:CC:DD:EE:FF" -&gt; "aabbccddeeff"
func NormalizeMAC(mac string) string <span class="cov8" title="1">{
        normalized := strings.ToLower(mac)
        normalized = strings.ReplaceAll(normalized, ":", "")
        normalized = strings.ReplaceAll(normalized, "-", "")
        return normalized
}</span>

// FormatMAC formats a MAC address with colon separators.
// Example: "aabbccddeeff" -&gt; "aa:bb:cc:dd:ee:ff"
func FormatMAC(mac string) string <span class="cov8" title="1">{
        normalized := NormalizeMAC(mac)
        if len(normalized) != 12 </span><span class="cov8" title="1">{
                return mac // Return as-is if invalid length
        }</span>

        <span class="cov8" title="1">var formatted strings.Builder
        for i := 0; i &lt; len(normalized); i += 2 </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        formatted.WriteString(":")
                }</span>
                <span class="cov8" title="1">formatted.WriteString(normalized[i : i+2])</span>
        }
        <span class="cov8" title="1">return formatted.String()</span>
}

// ValidateMAC checks if a MAC address is valid.
func ValidateMAC(mac string) bool <span class="cov8" title="1">{
        if mac == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return macRegex.MatchString(mac)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package internal

import (
        "fmt"
        "path"
)

const (
        // BasePath is the UniFi Network Application base path on UDM Pro
        BasePath = "/proxy/network"

        // APIv1Base is the base path for v1 API endpoints
        APIv1Base = "/api"

        // APIv2Base is the base path for v2 API endpoints
        APIv2Base = "/v2/api"
)

// BuildAPIPath builds a v1 API path for a given site and endpoint.
// Example: BuildAPIPath("default", "stat/device") -&gt; "/proxy/network/api/s/default/stat/device"
func BuildAPIPath(site, endpoint string) string <span class="cov8" title="1">{
        if site == "" </span><span class="cov8" title="1">{
                site = "default"
        }</span>
        <span class="cov8" title="1">return path.Join(BasePath, APIv1Base, "s", site, endpoint)</span>
}

// BuildV2APIPath builds a v2 API path for a given site and endpoint.
// Example: BuildV2APIPath("default", "site/default/trafficrules") -&gt; "/proxy/network/v2/api/site/default/trafficrules"
func BuildV2APIPath(site, endpoint string) string <span class="cov8" title="1">{
        if site == "" </span><span class="cov8" title="1">{
                site = "default"
        }</span>
        // v2 API uses full path including site in endpoint
        <span class="cov8" title="1">return path.Join(BasePath, APIv2Base, endpoint)</span>
}

// BuildRESTPath builds a REST API path for a given site, resource, and optional ID.
// Example: BuildRESTPath("default", "networkconf", "abc123") -&gt; "/proxy/network/api/s/default/rest/networkconf/abc123"
func BuildRESTPath(site, resource, id string) string <span class="cov8" title="1">{
        if site == "" </span><span class="cov8" title="1">{
                site = "default"
        }</span>

        <span class="cov8" title="1">basePath := path.Join(BasePath, APIv1Base, "s", site, "rest", resource)

        if id != "" </span><span class="cov8" title="1">{
                return path.Join(basePath, id)
        }</span>

        <span class="cov8" title="1">return basePath</span>
}

// BuildCmdPath builds a command API path for a given site and manager.
// Example: BuildCmdPath("default", "device") -&gt; "/proxy/network/api/s/default/cmd/devmgr"
func BuildCmdPath(site, manager string) string <span class="cov8" title="1">{
        if site == "" </span><span class="cov8" title="1">{
                site = "default"
        }</span>

        // Manager names follow pattern: devmgr, stamgr, sitemgr
        <span class="cov8" title="1">if manager != "" &amp;&amp; manager[len(manager)-3:] != "mgr" </span><span class="cov8" title="1">{
                manager = manager + "mgr"
        }</span>

        <span class="cov8" title="1">return path.Join(BasePath, APIv1Base, "s", site, "cmd", manager)</span>
}

// BuildAuthPath builds an authentication API path.
// Example: BuildAuthPath("login") -&gt; "/api/auth/login"
func BuildAuthPath(endpoint string) string <span class="cov8" title="1">{
        return fmt.Sprintf("/api/auth/%s", endpoint)
}</span>

// BuildSystemPath builds a system API path (no site required).
// Example: BuildSystemPath("status") -&gt; "/api/status"
func BuildSystemPath(endpoint string) string <span class="cov8" title="1">{
        return fmt.Sprintf("/api/%s", endpoint)
}</span>

// BuildWebSocketPath builds a WebSocket path for event streaming.
// Example: BuildWebSocketPath("default") -&gt; "/proxy/network/wss/s/default/events"
func BuildWebSocketPath(site string) string <span class="cov8" title="1">{
        if site == "" </span><span class="cov8" title="1">{
                site = "default"
        }</span>
        <span class="cov8" title="1">return path.Join(BasePath, "wss", "s", site, "events")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package mock

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/unifi-go/gofi/types"
)

// Fixtures holds test fixture data.
type Fixtures struct {
        Sites        []types.Site        `json:"sites,omitempty"`
        Devices      []types.Device      `json:"devices,omitempty"`
        Networks     []types.Network     `json:"networks,omitempty"`
        WLANs        []types.WLAN        `json:"wlans,omitempty"`
        Clients      []types.Client      `json:"clients,omitempty"`
        Users        []types.User        `json:"users,omitempty"`
        FirewallRules []types.FirewallRule `json:"firewall_rules,omitempty"`
}

// DefaultFixtures returns a minimal set of fixtures.
func DefaultFixtures() *Fixtures <span class="cov8" title="1">{
        return &amp;Fixtures{
                Sites: []types.Site{
                        {
                                ID:   "default",
                                Name: "default",
                                Desc: "Default Site",
                        },
                },
        }
}</span>

// LoadFixtures loads fixtures from a directory.
// The directory should contain JSON files named: sites.json, devices.json, etc.
func LoadFixtures(dir string) (*Fixtures, error) <span class="cov8" title="1">{
        fixtures := &amp;Fixtures{}

        files := map[string]interface{}{
                "sites.json":    &amp;fixtures.Sites,
                "devices.json":  &amp;fixtures.Devices,
                "networks.json": &amp;fixtures.Networks,
                "wlans.json":    &amp;fixtures.WLANs,
                "clients.json":  &amp;fixtures.Clients,
                "users.json":    &amp;fixtures.Users,
        }

        for filename, target := range files </span><span class="cov8" title="1">{
                path := filepath.Join(dir, filename)
                data, err := os.ReadFile(path)
                if err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                continue</span> // Optional file
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to read %s: %w", filename, err)</span>
                }

                <span class="cov8" title="1">if err := json.Unmarshal(data, target); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse %s: %w", filename, err)
                }</span>
        }

        <span class="cov8" title="1">return fixtures, nil</span>
}

// LoadFixtures loads fixtures into the state.
func (s *State) LoadFixtures(fixtures *Fixtures) <span class="cov8" title="1">{
        if fixtures == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">s.mu.Lock()
        defer s.mu.Unlock()

        // Load sites
        for _, site := range fixtures.Sites </span><span class="cov8" title="1">{
                siteCopy := site
                s.sites[site.ID] = &amp;siteCopy
        }</span>

        // Load devices
        <span class="cov8" title="1">for _, device := range fixtures.Devices </span><span class="cov8" title="1">{
                deviceCopy := device
                s.devices[device.ID] = &amp;deviceCopy
        }</span>

        // Load networks
        <span class="cov8" title="1">for _, network := range fixtures.Networks </span><span class="cov8" title="1">{
                networkCopy := network
                s.networks[network.ID] = &amp;networkCopy
        }</span>

        // Load WLANs
        <span class="cov8" title="1">for _, wlan := range fixtures.WLANs </span><span class="cov0" title="0">{
                wlanCopy := wlan
                s.wlans[wlan.ID] = &amp;wlanCopy
        }</span>

        // Load clients
        <span class="cov8" title="1">for _, client := range fixtures.Clients </span><span class="cov0" title="0">{
                clientCopy := client
                s.clients[client.MAC] = &amp;clientCopy
        }</span>

        // Load users
        <span class="cov8" title="1">for _, user := range fixtures.Users </span><span class="cov0" title="0">{
                userCopy := user
                s.users[user.ID] = &amp;userCopy
        }</span>

        // Load firewall rules
        <span class="cov8" title="1">for _, rule := range fixtures.FirewallRules </span><span class="cov0" title="0">{
                ruleCopy := rule
                s.firewallRules[rule.ID] = &amp;ruleCopy
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package mock

import (
        "encoding/json"
        "net/http"

        "github.com/unifi-go/gofi/types"
)

// handleLogin handles login requests.
func (s *Server) handleLogin(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov8" title="1">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        // Parse credentials
        <span class="cov8" title="1">var creds struct {
                Username string `json:"username"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;creds); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Validate credentials
        <span class="cov8" title="1">if !s.state.ValidateCredentials(creds.Username, creds.Password) </span><span class="cov8" title="1">{
                writeAPIError(w, http.StatusUnauthorized, "error", "Invalid credentials")
                return
        }</span>

        // Create session
        <span class="cov8" title="1">token := generateToken()
        csrfToken := generateCSRFToken()

        session := &amp;Session{
                Username:  creds.Username,
                CSRFToken: csrfToken,
        }

        s.state.CreateSession(token, session)

        // Set session cookie
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "unifises",
                Value:    token,
                Path:     "/",
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteLaxMode,
        })

        // Set CSRF token in header
        w.Header().Set("X-CSRF-Token", csrfToken)

        // Return success
        resp := types.APIResponse[interface{}]{
                Meta: types.ResponseMeta{RC: "ok"},
                Data: []interface{}{},
        }

        writeJSON(w, http.StatusOK, resp)</span>
}

// handleLogout handles logout requests.
func (s *Server) handleLogout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        // Get session cookie
        <span class="cov8" title="1">cookie, err := r.Cookie("unifises")
        if err == nil </span><span class="cov8" title="1">{
                s.state.DeleteSession(cookie.Value)
        }</span>

        // Clear cookie
        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:   "unifises",
                Value:  "",
                Path:   "/",
                MaxAge: -1,
        })

        // Return success
        resp := types.APIResponse[interface{}]{
                Meta: types.ResponseMeta{RC: "ok"},
                Data: []interface{}{},
        }

        writeJSON(w, http.StatusOK, resp)</span>
}

// handleStatus handles status requests (no auth required).
func (s *Server) handleStatus(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        status := &amp;types.Status{
                Up:      true,
                Version: "7.5.174",
        }

        // Status endpoint returns direct JSON, not API response wrapper
        writeJSON(w, http.StatusOK, status)
}</span>

// handleSelf handles self requests.
func (s *Server) handleSelf(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Get session
        cookie, err := r.Cookie("unifises")
        if err != nil </span><span class="cov0" title="0">{
                writeUnauthorized(w)
                return
        }</span>

        <span class="cov8" title="1">session, exists := s.state.GetSession(cookie.Value)
        if !exists </span><span class="cov0" title="0">{
                writeUnauthorized(w)
                return
        }</span>

        <span class="cov8" title="1">admin := &amp;types.AdminUser{
                Name:  session.Username,
                Email: session.Username + "@example.com",
        }

        // Self endpoint returns data in API response format (array)
        writeAPIResponse(w, []interface{}{*admin})</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/unifi-go/gofi/types"
)

// handleClients routes client/station requests.
func (s *Server) handleClients(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Client stat endpoints
        if strings.Contains(path, "/stat/sta") </span><span class="cov8" title="1">{
                s.handleClientStat(w, r, site)
                return
        }</span>

        <span class="cov8" title="1">if strings.Contains(path, "/stat/alluser") </span><span class="cov8" title="1">{
                s.handleAllUserStat(w, r, site)
                return
        }</span>

        // Client commands
        <span class="cov8" title="1">if strings.Contains(path, "/cmd/stamgr") </span><span class="cov8" title="1">{
                s.handleClientCommand(w, r, site)
                return
        }</span>

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleClientStat returns active clients.
func (s *Server) handleClientStat(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">clients := s.state.ListClients()

        // Filter active clients (seen in last 5 minutes)
        now := time.Now().Unix()
        activeClients := make([]interface{}, 0)
        for _, client := range clients </span><span class="cov8" title="1">{
                if client.LastSeen &gt; 0 &amp;&amp; now-client.LastSeen &lt; 300 </span><span class="cov8" title="1">{
                        activeClients = append(activeClients, *client)
                }</span>
        }

        <span class="cov8" title="1">writeAPIResponse(w, activeClients)</span>
}

// handleAllUserStat returns all clients with history.
func (s *Server) handleAllUserStat(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        // Parse within_hours parameter
        <span class="cov8" title="1">withinHours := 8760 // Default: 1 year
        if hours := r.URL.Query().Get("within"); hours != "" </span><span class="cov8" title="1">{
                if h, err := strconv.Atoi(hours); err == nil </span><span class="cov8" title="1">{
                        withinHours = h
                }</span>
        }

        <span class="cov8" title="1">clients := s.state.ListClients()

        // Filter by time window
        cutoff := time.Now().Unix() - int64(withinHours*3600)
        filteredClients := make([]interface{}, 0)
        for _, client := range clients </span><span class="cov8" title="1">{
                if client.LastSeen &gt;= cutoff </span><span class="cov8" title="1">{
                        filteredClients = append(filteredClients, *client)
                }</span>
        }

        <span class="cov8" title="1">writeAPIResponse(w, filteredClients)</span>
}

// handleClientCommand processes client management commands.
func (s *Server) handleClientCommand(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        // Parse command
        <span class="cov8" title="1">var cmd struct {
                CMD  string `json:"cmd"`
                MAC  string `json:"mac"`
                // Guest authorization options
                Minutes int    `json:"minutes,omitempty"`
                Up      int    `json:"up,omitempty"`
                Down    int    `json:"down,omitempty"`
                Bytes   int    `json:"bytes,omitempty"`
                APMAC   string `json:"ap_mac,omitempty"`
                // Device fingerprint
                DevID   int    `json:"dev_id,omitempty"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        <span class="cov8" title="1">if cmd.MAC == "" </span><span class="cov0" title="0">{
                writeBadRequest(w, "MAC address required")
                return
        }</span>

        // Get or create client
        <span class="cov8" title="1">client := s.state.GetClient(cmd.MAC)
        if client == nil </span><span class="cov8" title="1">{
                // For some commands, client must exist
                if cmd.CMD != "authorize-guest" </span><span class="cov0" title="0">{
                        writeNotFound(w)
                        return
                }</span>
                // Create guest client
                <span class="cov8" title="1">client = &amp;types.Client{
                        MAC:       cmd.MAC,
                        IsGuest:   true,
                        FirstSeen: time.Now().Unix(),
                        LastSeen:  time.Now().Unix(),
                }
                s.state.AddClient(client)</span>
        }

        // Execute command
        <span class="cov8" title="1">switch cmd.CMD </span>{
        case "block-sta":<span class="cov8" title="1">
                client.Blocked = true
                s.state.UpdateClient(client)</span>
        case "unblock-sta":<span class="cov8" title="1">
                client.Blocked = false
                s.state.UpdateClient(client)</span>
        case "kick-sta":<span class="cov8" title="1">
                client.GuestKicked = true
                // In real controller, this would disconnect the client
                s.state.UpdateClient(client)</span>
        case "forget-sta":<span class="cov8" title="1">
                s.state.DeleteClient(cmd.MAC)</span>
        case "authorize-guest":<span class="cov8" title="1">
                client.GuestAuthorized = true
                client.Authorized = true
                if cmd.Minutes &gt; 0 </span><span class="cov8" title="1">{
                        // Set expiration (not fully modeled in mock)
                        client.LastSeen = time.Now().Unix()
                }</span>
                <span class="cov8" title="1">s.state.UpdateClient(client)</span>
        case "unauthorize-guest":<span class="cov8" title="1">
                client.GuestAuthorized = false
                client.Authorized = false
                s.state.UpdateClient(client)</span>
        case "set-sta-dev-id":<span class="cov0" title="0">
                if cmd.DevID &gt; 0 </span><span class="cov0" title="0">{
                        client.DeviceIDOverride = cmd.DevID
                        s.state.UpdateClient(client)
                }</span>
        default:<span class="cov0" title="0">
                writeBadRequest(w, "Unknown command: "+cmd.CMD)
                return</span>
        }

        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package mock

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleDevices routes device-related requests.
func (s *Server) handleDevices(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // stat/device - list all devices
        if strings.Contains(path, "/stat/device") &amp;&amp; r.Method == "GET" </span><span class="cov8" title="1">{
                s.handleDeviceStat(w, r, site)
                return
        }</span>

        // basicstat/device - list device basics
        <span class="cov8" title="1">if strings.Contains(path, "/basicstat/device") &amp;&amp; r.Method == "GET" </span><span class="cov8" title="1">{
                s.handleDeviceBasicStat(w, r, site)
                return
        }</span>

        // rest/device/{id} - update device
        <span class="cov8" title="1">if strings.Contains(path, "/rest/device/") &amp;&amp; r.Method == "PUT" </span><span class="cov8" title="1">{
                parts := strings.Split(path, "/")
                for i, part := range parts </span><span class="cov8" title="1">{
                        if part == "device" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov8" title="1">{
                                id := parts[i+1]
                                s.handleDeviceUpdate(w, r, site, id)
                                return
                        }</span>
                }
        }

        // cmd/devmgr - device commands
        <span class="cov8" title="1">if strings.Contains(path, "/cmd/devmgr") &amp;&amp; r.Method == "POST" </span><span class="cov8" title="1">{
                s.handleDeviceCommand(w, r, site)
                return
        }</span>

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleDeviceStat returns all devices for a site.
func (s *Server) handleDeviceStat(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">devices := s.state.ListDevices()

        // Convert to interface slice
        data := make([]interface{}, len(devices))
        for i, device := range devices </span><span class="cov8" title="1">{
                data[i] = *device
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleDeviceBasicStat returns basic device info.
func (s *Server) handleDeviceBasicStat(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">devices := s.state.ListDevices()

        // Convert to basic format
        basics := make([]types.DeviceBasic, len(devices))
        for i, device := range devices </span><span class="cov8" title="1">{
                basics[i] = types.DeviceBasic{
                        MAC:   device.MAC,
                        Type:  device.Type,
                        Model: device.Model,
                        Name:  device.Name,
                        State: device.State,
                }
        }</span>

        // Convert to interface slice
        <span class="cov8" title="1">data := make([]interface{}, len(basics))
        for i, basic := range basics </span><span class="cov8" title="1">{
                data[i] = basic
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleDeviceUpdate updates a device.
func (s *Server) handleDeviceUpdate(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        if r.Method != "PUT" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        // Get existing device
        <span class="cov8" title="1">device, exists := s.state.GetDevice(id)
        if !exists </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        // Parse update request
        <span class="cov8" title="1">var updateReq types.Device
        if err := json.NewDecoder(r.Body).Decode(&amp;updateReq); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Update fields (only certain fields can be updated)
        <span class="cov8" title="1">if updateReq.Name != "" </span><span class="cov8" title="1">{
                device.Name = updateReq.Name
        }</span>
        <span class="cov8" title="1">if updateReq.LEDOverride != "" </span><span class="cov0" title="0">{
                device.LEDOverride = updateReq.LEDOverride
        }</span>
        <span class="cov8" title="1">if updateReq.LEDOverrideColor != "" </span><span class="cov0" title="0">{
                device.LEDOverrideColor = updateReq.LEDOverrideColor
        }</span>

        // Save updated device
        <span class="cov8" title="1">s.state.AddDevice(device)

        // Return updated device
        writeAPIResponse(w, []interface{}{*device})</span>
}

// handleDeviceCommand handles device commands.
func (s *Server) handleDeviceCommand(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        // Parse command request
        <span class="cov8" title="1">var cmdReq types.CommandRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;cmdReq); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Validate MAC address for most commands
        <span class="cov8" title="1">if cmdReq.MAC == "" &amp;&amp; cmdReq.Cmd != "set-default" </span><span class="cov0" title="0">{
                writeBadRequest(w, "MAC address required")
                return
        }</span>

        // Find device by MAC
        <span class="cov8" title="1">var device *types.Device
        if cmdReq.MAC != "" </span><span class="cov8" title="1">{
                devices := s.state.ListDevices()
                for i := range devices </span><span class="cov8" title="1">{
                        if strings.EqualFold(devices[i].MAC, cmdReq.MAC) </span><span class="cov8" title="1">{
                                device = devices[i]
                                break</span>
                        }
                }

                <span class="cov8" title="1">if device == nil </span><span class="cov0" title="0">{
                        writeAPIError(w, http.StatusNotFound, "error", "Device not found")
                        return
                }</span>
        }

        // Handle different commands
        <span class="cov8" title="1">switch cmdReq.Cmd </span>{
        case "adopt":<span class="cov8" title="1">
                if device != nil </span><span class="cov8" title="1">{
                        device.Adopted = true
                        device.State = types.DeviceStateConnected
                        s.state.AddDevice(device)
                }</span>
        case "restart":<span class="cov0" title="0"></span>
                // Simulate restart - no state change needed
        case "force-provision":<span class="cov0" title="0">
                if device != nil </span><span class="cov0" title="0">{
                        device.State = types.DeviceStateProvisioning
                        s.state.AddDevice(device)
                }</span>
        case "upgrade":<span class="cov0" title="0">
                if device != nil </span><span class="cov0" title="0">{
                        device.State = types.DeviceStateUpgrading
                        s.state.AddDevice(device)
                }</span>
        case "upgrade-external":<span class="cov0" title="0">
                if cmdReq.URL == "" </span><span class="cov0" title="0">{
                        writeBadRequest(w, "URL required for external upgrade")
                        return
                }</span>
                <span class="cov0" title="0">if device != nil </span><span class="cov0" title="0">{
                        device.State = types.DeviceStateUpgrading
                        s.state.AddDevice(device)
                }</span>
        case "set-locate":<span class="cov8" title="1">
                if device != nil </span><span class="cov8" title="1">{
                        device.LEDOverride = "on"
                        s.state.AddDevice(device)
                }</span>
        case "unset-locate":<span class="cov8" title="1">
                if device != nil </span><span class="cov8" title="1">{
                        device.LEDOverride = "default"
                        s.state.AddDevice(device)
                }</span>
        case "power-cycle":<span class="cov8" title="1">
                if cmdReq.PortIdx == 0 </span><span class="cov8" title="1">{
                        writeBadRequest(w, "port_idx required")
                        return
                }</span>
                // Simulate power cycle - no state change needed
        case "spectrum-scan":<span class="cov0" title="0"></span>
                // Simulate spectrum scan - no state change needed
        default:<span class="cov8" title="1">
                writeBadRequest(w, fmt.Sprintf("Unknown command: %s", cmdReq.Cmd))
                return</span>
        }

        // Return success
        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleFirewall routes firewall-related requests.
func (s *Server) handleFirewall(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Firewall Group endpoints: /rest/firewallgroup
        if strings.Contains(path, "/rest/firewallgroup") </span><span class="cov8" title="1">{
                s.handleFirewallGroups(w, r, site)
                return
        }</span>

        // Firewall Rule endpoints: /rest/firewallrule
        <span class="cov8" title="1">if strings.Contains(path, "/rest/firewallrule") </span><span class="cov8" title="1">{
                // Check if this is a reorder request
                if strings.Contains(path, "/reorder") &amp;&amp; r.Method == "POST" </span><span class="cov0" title="0">{
                        s.handleFirewallReorder(w, r, site)
                        return
                }</span>

                // Extract ID if present
                <span class="cov8" title="1">parts := strings.Split(path, "/")
                var id string
                for i, part := range parts </span><span class="cov8" title="1">{
                        if part == "firewallrule" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" &amp;&amp; parts[i+1] != "reorder" </span><span class="cov0" title="0">{
                                id = parts[i+1]
                                break</span>
                        }
                }

                <span class="cov8" title="1">switch r.Method </span>{
                case "GET":<span class="cov8" title="1">
                        if id != "" </span><span class="cov0" title="0">{
                                s.handleGetFirewallRule(w, r, site, id)
                        }</span> else<span class="cov8" title="1"> {
                                s.handleListFirewallRules(w, r, site)
                        }</span>
                case "POST":<span class="cov8" title="1">
                        s.handleCreateFirewallRule(w, r, site)</span>
                case "PUT":<span class="cov0" title="0">
                        if id != "" </span><span class="cov0" title="0">{
                                s.handleUpdateFirewallRule(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "Firewall rule ID required for update")
                        }</span>
                case "DELETE":<span class="cov0" title="0">
                        if id != "" </span><span class="cov0" title="0">{
                                s.handleDeleteFirewallRule(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "Firewall rule ID required for delete")
                        }</span>
                default:<span class="cov0" title="0">
                        writeNotFound(w)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleListFirewallRules returns all firewall rules for a site.
func (s *Server) handleListFirewallRules(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">rules := s.state.ListFirewallRules()

        data := make([]interface{}, len(rules))
        for i, rule := range rules </span><span class="cov8" title="1">{
                data[i] = *rule
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetFirewallRule returns a specific firewall rule by ID.
func (s *Server) handleGetFirewallRule(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">rule := s.state.GetFirewallRule(id)
        if rule == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*rule})</span>
}

// handleCreateFirewallRule creates a new firewall rule.
func (s *Server) handleCreateFirewallRule(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">var rule types.FirewallRule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if rule.Name == "" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Firewall rule name is required")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if rule.ID == "" </span><span class="cov8" title="1">{
                rule.ID = generateID()
        }</span>
        <span class="cov8" title="1">rule.SiteID = site

        s.state.AddFirewallRule(&amp;rule)

        writeAPIResponse(w, []interface{}{rule})</span>
}

// handleUpdateFirewallRule updates an existing firewall rule.
func (s *Server) handleUpdateFirewallRule(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        if r.Method != "PUT" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">existing := s.state.GetFirewallRule(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">var rule types.FirewallRule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Preserve ID and site
        <span class="cov0" title="0">rule.ID = id
        rule.SiteID = site

        s.state.UpdateFirewallRule(&amp;rule)

        writeAPIResponse(w, []interface{}{rule})</span>
}

// handleDeleteFirewallRule deletes a firewall rule.
func (s *Server) handleDeleteFirewallRule(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        if r.Method != "DELETE" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">existing := s.state.GetFirewallRule(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteFirewallRule(id)

        writeAPIResponse(w, []interface{}{})</span>
}

// handleFirewallReorder handles reordering firewall rules.
func (s *Server) handleFirewallReorder(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">var updates []types.FirewallRuleIndexUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;updates); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Update rule indices
        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                rule := s.state.GetFirewallRule(update.ID)
                if rule != nil </span><span class="cov0" title="0">{
                        rule.RuleIndex = update.RuleIndex
                        s.state.UpdateFirewallRule(rule)
                }</span>
        }

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{})</span>
}

// handleFirewallGroups routes firewall group requests.
func (s *Server) handleFirewallGroups(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Extract ID if present
        parts := strings.Split(path, "/")
        var id string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "firewallgroup" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov0" title="0">{
                        id = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleGetFirewallGroup(w, r, site, id)
                }</span> else<span class="cov8" title="1"> {
                        s.handleListFirewallGroups(w, r, site)
                }</span>
        case "POST":<span class="cov0" title="0">
                s.handleCreateFirewallGroup(w, r, site)</span>
        case "PUT":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleUpdateFirewallGroup(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Firewall group ID required for update")
                }</span>
        case "DELETE":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleDeleteFirewallGroup(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Firewall group ID required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleListFirewallGroups returns all firewall groups for a site.
func (s *Server) handleListFirewallGroups(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        groups := s.state.ListFirewallGroups()

        data := make([]interface{}, len(groups))
        for i, group := range groups </span><span class="cov8" title="1">{
                data[i] = *group
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetFirewallGroup returns a specific firewall group by ID.
func (s *Server) handleGetFirewallGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        group := s.state.GetFirewallGroup(id)
        if group == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*group})</span>
}

// handleCreateFirewallGroup creates a new firewall group.
func (s *Server) handleCreateFirewallGroup(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        var group types.FirewallGroup
        if err := json.NewDecoder(r.Body).Decode(&amp;group); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if group.Name == "" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Firewall group name is required")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">if group.ID == "" </span><span class="cov0" title="0">{
                group.ID = generateID()
        }</span>
        <span class="cov0" title="0">group.SiteID = site

        s.state.AddFirewallGroup(&amp;group)

        writeAPIResponse(w, []interface{}{group})</span>
}

// handleUpdateFirewallGroup updates an existing firewall group.
func (s *Server) handleUpdateFirewallGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        existing := s.state.GetFirewallGroup(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">var group types.FirewallGroup
        if err := json.NewDecoder(r.Body).Decode(&amp;group); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Preserve ID and site
        <span class="cov0" title="0">group.ID = id
        group.SiteID = site

        s.state.UpdateFirewallGroup(&amp;group)

        writeAPIResponse(w, []interface{}{group})</span>
}

// handleDeleteFirewallGroup deletes a firewall group.
func (s *Server) handleDeleteFirewallGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        existing := s.state.GetFirewallGroup(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteFirewallGroup(id)

        writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleNetworks routes network-related requests.
func (s *Server) handleNetworks(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        path := r.URL.Path

        // Check if this is a specific network ID request
        if strings.Contains(path, "/rest/networkconf/") </span><span class="cov0" title="0">{
                // Extract ID from path
                parts := strings.Split(path, "/")
                for i, part := range parts </span><span class="cov0" title="0">{
                        if part == "networkconf" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov0" title="0">{
                                id := parts[i+1]
                                switch r.Method </span>{
                                case "GET":<span class="cov0" title="0">
                                        s.handleGetNetwork(w, r, site, id)</span>
                                case "PUT":<span class="cov0" title="0">
                                        s.handleUpdateNetwork(w, r, site, id)</span>
                                case "DELETE":<span class="cov0" title="0">
                                        s.handleDeleteNetwork(w, r, site, id)</span>
                                default:<span class="cov0" title="0">
                                        writeBadRequest(w, "Method not allowed")</span>
                                }
                                <span class="cov0" title="0">return</span>
                        }
                }
        }

        // List or create
        <span class="cov0" title="0">if strings.HasSuffix(path, "/rest/networkconf") </span><span class="cov0" title="0">{
                switch r.Method </span>{
                case "GET":<span class="cov0" title="0">
                        s.handleListNetworks(w, r, site)</span>
                case "POST":<span class="cov0" title="0">
                        s.handleCreateNetwork(w, r, site)</span>
                default:<span class="cov0" title="0">
                        writeBadRequest(w, "Method not allowed")</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleListNetworks returns all networks for a site.
func (s *Server) handleListNetworks(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        networks := s.state.ListNetworks()

        // Convert to interface slice
        data := make([]interface{}, len(networks))
        for i, network := range networks </span><span class="cov0" title="0">{
                data[i] = *network
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, data)</span>
}

// handleGetNetwork returns a specific network.
func (s *Server) handleGetNetwork(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        network, exists := s.state.GetNetwork(id)
        if !exists </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*network})</span>
}

// handleCreateNetwork creates a new network.
func (s *Server) handleCreateNetwork(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        var network types.Network
        if err := json.NewDecoder(r.Body).Decode(&amp;network); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">if network.ID == "" </span><span class="cov0" title="0">{
                network.ID = generateToken()
        }</span>
        <span class="cov0" title="0">network.SiteID = site

        s.state.AddNetwork(&amp;network)

        writeAPIResponse(w, []interface{}{network})</span>
}

// handleUpdateNetwork updates a network.
func (s *Server) handleUpdateNetwork(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        // Get existing network
        existing, exists := s.state.GetNetwork(id)
        if !exists </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        // Parse update request
        <span class="cov0" title="0">var updateReq types.Network
        if err := json.NewDecoder(r.Body).Decode(&amp;updateReq); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Preserve ID and site
        <span class="cov0" title="0">updateReq.ID = existing.ID
        updateReq.SiteID = existing.SiteID

        // Save updated network
        s.state.AddNetwork(&amp;updateReq)

        writeAPIResponse(w, []interface{}{updateReq})</span>
}

// handleDeleteNetwork deletes a network.
func (s *Server) handleDeleteNetwork(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        _, exists := s.state.GetNetwork(id)
        if !exists </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteNetwork(id)

        writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handlePorts routes port-related requests (forwarding and profiles).
func (s *Server) handlePorts(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Port forwarding endpoints: /rest/portforward
        if strings.Contains(path, "/rest/portforward") </span><span class="cov8" title="1">{
                s.handlePortForward(w, r, site)
                return
        }</span>

        // Port profile endpoints: /rest/portconf
        <span class="cov8" title="1">if strings.Contains(path, "/rest/portconf") </span><span class="cov8" title="1">{
                s.handlePortProfile(w, r, site)
                return
        }</span>

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handlePortForward routes port forwarding requests.
func (s *Server) handlePortForward(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path
        parts := strings.Split(path, "/")
        var id string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "portforward" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov0" title="0">{
                        id = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleGetPortForward(w, r, site, id)
                }</span> else<span class="cov8" title="1"> {
                        s.handleListPortForwards(w, r, site)
                }</span>
        case "POST":<span class="cov8" title="1">
                s.handleCreatePortForward(w, r, site)</span>
        case "PUT":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleUpdatePortForward(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Port forward ID required for update")
                }</span>
        case "DELETE":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleDeletePortForward(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Port forward ID required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleListPortForwards returns all port forwards.
func (s *Server) handleListPortForwards(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        forwards := s.state.ListPortForwards()

        data := make([]interface{}, len(forwards))
        for i, forward := range forwards </span><span class="cov8" title="1">{
                data[i] = *forward
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetPortForward returns a specific port forward by ID.
func (s *Server) handleGetPortForward(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        forward := s.state.GetPortForward(id)
        if forward == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*forward})</span>
}

// handleCreatePortForward creates a new port forward.
func (s *Server) handleCreatePortForward(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        var forward types.PortForward
        if err := json.NewDecoder(r.Body).Decode(&amp;forward); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if forward.ID == "" </span><span class="cov8" title="1">{
                forward.ID = generateID()
        }</span>

        // Set site ID
        <span class="cov8" title="1">if forward.SiteID == "" </span><span class="cov8" title="1">{
                forward.SiteID = site
        }</span>

        <span class="cov8" title="1">s.state.AddPortForward(&amp;forward)
        writeAPIResponse(w, []interface{}{forward})</span>
}

// handleUpdatePortForward updates an existing port forward.
func (s *Server) handleUpdatePortForward(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        existing := s.state.GetPortForward(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">var forward types.PortForward
        if err := json.NewDecoder(r.Body).Decode(&amp;forward); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Preserve ID and site ID
        <span class="cov0" title="0">forward.ID = id
        forward.SiteID = existing.SiteID

        s.state.UpdatePortForward(&amp;forward)
        writeAPIResponse(w, []interface{}{forward})</span>
}

// handleDeletePortForward deletes a port forward.
func (s *Server) handleDeletePortForward(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        if s.state.GetPortForward(id) == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeletePortForward(id)
        writeAPIResponse(w, []interface{}{})</span>
}

// handlePortProfile routes port profile requests.
func (s *Server) handlePortProfile(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path
        parts := strings.Split(path, "/")
        var id string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "portconf" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov8" title="1">{
                        id = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                if id != "" </span><span class="cov8" title="1">{
                        s.handleGetPortProfile(w, r, site, id)
                }</span> else<span class="cov8" title="1"> {
                        s.handleListPortProfiles(w, r, site)
                }</span>
        case "POST":<span class="cov8" title="1">
                s.handleCreatePortProfile(w, r, site)</span>
        case "PUT":<span class="cov8" title="1">
                if id != "" </span><span class="cov8" title="1">{
                        s.handleUpdatePortProfile(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Port profile ID required for update")
                }</span>
        case "DELETE":<span class="cov8" title="1">
                if id != "" </span><span class="cov8" title="1">{
                        s.handleDeletePortProfile(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Port profile ID required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleListPortProfiles returns all port profiles.
func (s *Server) handleListPortProfiles(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        profiles := s.state.ListPortProfiles()

        data := make([]interface{}, len(profiles))
        for i, profile := range profiles </span><span class="cov8" title="1">{
                data[i] = *profile
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetPortProfile returns a specific port profile by ID.
func (s *Server) handleGetPortProfile(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        profile := s.state.GetPortProfile(id)
        if profile == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{*profile})</span>
}

// handleCreatePortProfile creates a new port profile.
func (s *Server) handleCreatePortProfile(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        var profile types.PortProfile
        if err := json.NewDecoder(r.Body).Decode(&amp;profile); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if profile.ID == "" </span><span class="cov8" title="1">{
                profile.ID = generateID()
        }</span>

        // Set site ID
        <span class="cov8" title="1">if profile.SiteID == "" </span><span class="cov8" title="1">{
                profile.SiteID = site
        }</span>

        <span class="cov8" title="1">s.state.AddPortProfile(&amp;profile)
        writeAPIResponse(w, []interface{}{profile})</span>
}

// handleUpdatePortProfile updates an existing port profile.
func (s *Server) handleUpdatePortProfile(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        existing := s.state.GetPortProfile(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">var profile types.PortProfile
        if err := json.NewDecoder(r.Body).Decode(&amp;profile); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Preserve ID and site ID
        <span class="cov8" title="1">profile.ID = id
        profile.SiteID = existing.SiteID

        s.state.UpdatePortProfile(&amp;profile)
        writeAPIResponse(w, []interface{}{profile})</span>
}

// handleDeletePortProfile deletes a port profile.
func (s *Server) handleDeletePortProfile(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        if s.state.GetPortProfile(id) == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">s.state.DeletePortProfile(id)
        writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleRouting routes routing-related requests.
func (s *Server) handleRouting(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Routing endpoints: /rest/routing
        if strings.Contains(path, "/rest/routing") </span><span class="cov8" title="1">{
                parts := strings.Split(path, "/")
                var id string
                for i, part := range parts </span><span class="cov8" title="1">{
                        if part == "routing" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov8" title="1">{
                                id = parts[i+1]
                                break</span>
                        }
                }

                <span class="cov8" title="1">switch r.Method </span>{
                case "GET":<span class="cov8" title="1">
                        if id != "" </span><span class="cov8" title="1">{
                                s.handleGetRoute(w, r, site, id)
                        }</span> else<span class="cov8" title="1"> {
                                s.handleListRoutes(w, r, site)
                        }</span>
                case "POST":<span class="cov8" title="1">
                        s.handleCreateRoute(w, r, site)</span>
                case "PUT":<span class="cov8" title="1">
                        if id != "" </span><span class="cov8" title="1">{
                                s.handleUpdateRoute(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "Route ID required for update")
                        }</span>
                case "DELETE":<span class="cov8" title="1">
                        if id != "" </span><span class="cov8" title="1">{
                                s.handleDeleteRoute(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "Route ID required for delete")
                        }</span>
                default:<span class="cov0" title="0">
                        writeNotFound(w)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleListRoutes returns all routes.
func (s *Server) handleListRoutes(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        routes := s.state.ListRoutes()

        data := make([]interface{}, len(routes))
        for i, route := range routes </span><span class="cov8" title="1">{
                data[i] = *route
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetRoute returns a specific route by ID.
func (s *Server) handleGetRoute(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        route := s.state.GetRoute(id)
        if route == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{*route})</span>
}

// handleCreateRoute creates a new route.
func (s *Server) handleCreateRoute(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        var route types.Route
        if err := json.NewDecoder(r.Body).Decode(&amp;route); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if route.ID == "" </span><span class="cov8" title="1">{
                route.ID = generateID()
        }</span>

        // Set site ID
        <span class="cov8" title="1">if route.SiteID == "" </span><span class="cov8" title="1">{
                route.SiteID = site
        }</span>

        <span class="cov8" title="1">s.state.AddRoute(&amp;route)
        writeAPIResponse(w, []interface{}{route})</span>
}

// handleUpdateRoute updates an existing route.
func (s *Server) handleUpdateRoute(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        existing := s.state.GetRoute(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">var route types.Route
        if err := json.NewDecoder(r.Body).Decode(&amp;route); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Preserve ID and site ID
        <span class="cov8" title="1">route.ID = id
        route.SiteID = existing.SiteID

        s.state.UpdateRoute(&amp;route)
        writeAPIResponse(w, []interface{}{route})</span>
}

// handleDeleteRoute deletes a route.
func (s *Server) handleDeleteRoute(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        if s.state.GetRoute(id) == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">s.state.DeleteRoute(id)
        writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleSettings routes settings-related requests.
func (s *Server) handleSettings(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // RADIUS profile endpoints: /rest/radiusprofile
        if strings.Contains(path, "/rest/radiusprofile") </span><span class="cov8" title="1">{
                s.handleRADIUSProfiles(w, r, site)
                return
        }</span>

        // Dynamic DNS endpoints: /rest/dynamicdns
        <span class="cov8" title="1">if strings.Contains(path, "/rest/dynamicdns") </span><span class="cov8" title="1">{
                s.handleDynamicDNS(w, r, site)
                return
        }</span>

        // Setting endpoints: /rest/setting/{key}
        <span class="cov8" title="1">if strings.Contains(path, "/rest/setting") </span><span class="cov8" title="1">{
                parts := strings.Split(path, "/")
                var key string
                for i, part := range parts </span><span class="cov8" title="1">{
                        if part == "setting" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov8" title="1">{
                                key = parts[i+1]
                                break</span>
                        }
                }

                <span class="cov8" title="1">switch r.Method </span>{
                case "GET":<span class="cov8" title="1">
                        s.handleGetSetting(w, r, site, key)</span>
                case "PUT":<span class="cov8" title="1">
                        s.handleUpdateSetting(w, r, site, key)</span>
                default:<span class="cov0" title="0">
                        writeNotFound(w)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleGetSetting returns a setting by key.
func (s *Server) handleGetSetting(w http.ResponseWriter, r *http.Request, site, key string) <span class="cov8" title="1">{
        setting := s.state.GetSetting(key)
        if setting == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{*setting})</span>
}

// handleUpdateSetting updates a setting.
func (s *Server) handleUpdateSetting(w http.ResponseWriter, r *http.Request, site, key string) <span class="cov8" title="1">{
        var setting types.Setting
        if err := json.NewDecoder(r.Body).Decode(&amp;setting); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Ensure key matches
        <span class="cov8" title="1">setting.Key = key

        // Set site ID if not provided
        if setting.SiteID == "" </span><span class="cov0" title="0">{
                setting.SiteID = site
        }</span>

        <span class="cov8" title="1">s.state.UpdateSetting(&amp;setting)
        writeAPIResponse(w, []interface{}{setting})</span>
}

// handleRADIUSProfiles routes RADIUS profile requests.
func (s *Server) handleRADIUSProfiles(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path
        parts := strings.Split(path, "/")
        var id string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "radiusprofile" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov0" title="0">{
                        id = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleGetRADIUSProfile(w, r, site, id)
                }</span> else<span class="cov8" title="1"> {
                        s.handleListRADIUSProfiles(w, r, site)
                }</span>
        case "POST":<span class="cov8" title="1">
                s.handleCreateRADIUSProfile(w, r, site)</span>
        case "PUT":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleUpdateRADIUSProfile(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "RADIUS profile ID required for update")
                }</span>
        case "DELETE":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleDeleteRADIUSProfile(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "RADIUS profile ID required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleListRADIUSProfiles returns all RADIUS profiles.
func (s *Server) handleListRADIUSProfiles(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        profiles := s.state.ListRADIUSProfiles()

        data := make([]interface{}, len(profiles))
        for i, profile := range profiles </span><span class="cov8" title="1">{
                data[i] = *profile
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetRADIUSProfile returns a specific RADIUS profile by ID.
func (s *Server) handleGetRADIUSProfile(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        profile := s.state.GetRADIUSProfile(id)
        if profile == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*profile})</span>
}

// handleCreateRADIUSProfile creates a new RADIUS profile.
func (s *Server) handleCreateRADIUSProfile(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        var profile types.RADIUSProfile
        if err := json.NewDecoder(r.Body).Decode(&amp;profile); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if profile.ID == "" </span><span class="cov8" title="1">{
                profile.ID = generateID()
        }</span>

        // Set site ID
        <span class="cov8" title="1">if profile.SiteID == "" </span><span class="cov8" title="1">{
                profile.SiteID = site
        }</span>

        <span class="cov8" title="1">s.state.AddRADIUSProfile(&amp;profile)
        writeAPIResponse(w, []interface{}{profile})</span>
}

// handleUpdateRADIUSProfile updates an existing RADIUS profile.
func (s *Server) handleUpdateRADIUSProfile(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        existing := s.state.GetRADIUSProfile(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">var profile types.RADIUSProfile
        if err := json.NewDecoder(r.Body).Decode(&amp;profile); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Preserve ID and site ID
        <span class="cov0" title="0">profile.ID = id
        profile.SiteID = existing.SiteID

        s.state.UpdateRADIUSProfile(&amp;profile)
        writeAPIResponse(w, []interface{}{profile})</span>
}

// handleDeleteRADIUSProfile deletes a RADIUS profile.
func (s *Server) handleDeleteRADIUSProfile(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        if s.state.GetRADIUSProfile(id) == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteRADIUSProfile(id)
        writeAPIResponse(w, []interface{}{})</span>
}

// handleDynamicDNS routes Dynamic DNS requests (GET/PUT only, singleton).
func (s *Server) handleDynamicDNS(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                s.handleGetDynamicDNS(w, r, site)</span>
        case "PUT":<span class="cov8" title="1">
                s.handleUpdateDynamicDNS(w, r, site)</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleGetDynamicDNS returns the Dynamic DNS configuration.
func (s *Server) handleGetDynamicDNS(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        ddns := s.state.GetDynamicDNS()
        if ddns == nil </span><span class="cov0" title="0">{
                // Return empty array if not configured
                writeAPIResponse(w, []interface{}{})
                return
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{*ddns})</span>
}

// handleUpdateDynamicDNS updates the Dynamic DNS configuration.
func (s *Server) handleUpdateDynamicDNS(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        var ddns types.DynamicDNS
        if err := json.NewDecoder(r.Body).Decode(&amp;ddns); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if ddns.ID == "" </span><span class="cov8" title="1">{
                ddns.ID = generateID()
        }</span>

        // Set site ID
        <span class="cov8" title="1">if ddns.SiteID == "" </span><span class="cov8" title="1">{
                ddns.SiteID = site
        }</span>

        <span class="cov8" title="1">s.state.SetDynamicDNS(&amp;ddns)
        writeAPIResponse(w, []interface{}{ddns})</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleSites routes site-related requests.
func (s *Server) handleSites(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // /api/self/sites - list or create sites
        if strings.HasSuffix(path, "/api/self/sites") </span><span class="cov8" title="1">{
                if r.Method == "GET" </span><span class="cov8" title="1">{
                        s.handleListSites(w, r)
                }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                        s.handleCreateSite(w, r)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Method not allowed")
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // Health endpoint: /proxy/network/api/s/{site}/stat/health
        <span class="cov8" title="1">if strings.Contains(path, "/stat/health") </span><span class="cov8" title="1">{
                // Extract site from path
                parts := strings.Split(path, "/")
                for i, part := range parts </span><span class="cov8" title="1">{
                        if part == "s" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov8" title="1">{
                                site = parts[i+1]
                                break</span>
                        }
                }
                <span class="cov8" title="1">s.handleHealth(w, r, site)
                return</span>
        }

        // Sysinfo endpoint: /proxy/network/api/s/{site}/stat/sysinfo
        <span class="cov8" title="1">if strings.Contains(path, "/stat/sysinfo") </span><span class="cov8" title="1">{
                // Extract site from path
                parts := strings.Split(path, "/")
                for i, part := range parts </span><span class="cov8" title="1">{
                        if part == "s" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov8" title="1">{
                                site = parts[i+1]
                                break</span>
                        }
                }
                <span class="cov8" title="1">s.handleSysInfo(w, r, site)
                return</span>
        }

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleListSites returns all sites.
func (s *Server) handleListSites(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">sites := s.state.ListSites()

        // Convert to interface slice
        data := make([]interface{}, len(sites))
        for i, site := range sites </span><span class="cov8" title="1">{
                data[i] = site
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleHealth returns health information for a site.
func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        // Return mock health data
        <span class="cov8" title="1">health := []types.HealthData{
                {
                        Subsystem: "www",
                        Status:    "ok",
                },
                {
                        Subsystem: "wan",
                        Status:    "ok",
                        NumGw:     1,
                },
                {
                        Subsystem: "lan",
                        Status:    "ok",
                        NumSta:    5,
                },
        }

        // Convert to interface slice
        data := make([]interface{}, len(health))
        for i, h := range health </span><span class="cov8" title="1">{
                data[i] = h
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleSysInfo returns system information.
func (s *Server) handleSysInfo(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">sysInfo := &amp;types.SysInfo{
                Hostname:   "UDM-Pro",
                Version:    "7.5.174",
                HTTPSPort:  443,
                Console:    true,
                UpdateAvailable: false,
        }

        writeAPIResponse(w, sysInfo)</span>
}

// handleSiteREST handles REST operations on sites.
func (s *Server) handleSiteREST(w http.ResponseWriter, r *http.Request, siteID string) <span class="cov0" title="0">{
        switch r.Method </span>{
        case "GET":<span class="cov0" title="0">
                if siteID == "" </span><span class="cov0" title="0">{
                        s.handleListSites(w, r)
                }</span> else<span class="cov0" title="0"> {
                        s.handleGetSite(w, r, siteID)
                }</span>
        case "POST":<span class="cov0" title="0">
                s.handleCreateSite(w, r)</span>
        case "PUT":<span class="cov0" title="0">
                s.handleUpdateSite(w, r, siteID)</span>
        case "DELETE":<span class="cov0" title="0">
                s.handleDeleteSite(w, r, siteID)</span>
        default:<span class="cov0" title="0">
                writeBadRequest(w, "Method not allowed")</span>
        }
}

// handleGetSite returns a specific site.
func (s *Server) handleGetSite(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        site, exists := s.state.GetSite(id)
        if !exists </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, site)</span>
}

// handleCreateSite creates a new site.
func (s *Server) handleCreateSite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req types.CreateSiteRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID from name/desc
        <span class="cov8" title="1">id := req.Name
        if id == "" </span><span class="cov0" title="0">{
                id = strings.ToLower(strings.ReplaceAll(req.Desc, " ", "-"))
        }</span>

        // Create site
        <span class="cov8" title="1">site := &amp;types.Site{
                ID:   id,
                Name: id,
                Desc: req.Desc,
        }

        s.state.AddSite(site)

        writeAPIResponse(w, site)</span>
}

// handleUpdateSite updates a site.
func (s *Server) handleUpdateSite(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        site, exists := s.state.GetSite(id)
        if !exists </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">var req types.UpdateSiteRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.Desc != "" </span><span class="cov0" title="0">{
                site.Desc = req.Desc
        }</span>
        <span class="cov0" title="0">if req.Name != "" </span><span class="cov0" title="0">{
                site.Name = req.Name
        }</span>

        <span class="cov0" title="0">s.state.AddSite(site)

        writeAPIResponse(w, site)</span>
}

// handleDeleteSite deletes a site.
func (s *Server) handleDeleteSite(w http.ResponseWriter, r *http.Request, id string) <span class="cov0" title="0">{
        if id == "default" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Cannot delete default site")
                return
        }</span>

        <span class="cov0" title="0">_, exists := s.state.GetSite(id)
        if !exists </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteSite(id)

        writeAPIResponse(w, map[string]string{})</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package mock

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/unifi-go/gofi/types"
)

// handleSystem routes system-related requests.
func (s *Server) handleSystem(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Reboot endpoint: /api/cmd/system
        if strings.Contains(path, "/api/cmd/system") </span><span class="cov8" title="1">{
                s.handleReboot(w, r)
                return
        }</span>

        // Backup endpoints: /api/cmd/backup
        <span class="cov8" title="1">if strings.Contains(path, "/api/cmd/backup") </span><span class="cov8" title="1">{
                s.handleBackups(w, r)
                return
        }</span>

        // Admin list: /api/stat/admin
        <span class="cov8" title="1">if strings.Contains(path, "/api/stat/admin") </span><span class="cov8" title="1">{
                s.handleAdminList(w, r)
                return
        }</span>

        // Speed test endpoints (site-specific)
        <span class="cov8" title="1">if strings.Contains(path, "/cmd/speedtest") </span><span class="cov8" title="1">{
                s.handleSpeedTest(w, r, site)
                return
        }</span>

        <span class="cov8" title="1">if strings.Contains(path, "/stat/speedtest") </span><span class="cov8" title="1">{
                s.handleSpeedTestStatus(w, r, site)
                return
        }</span>

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleReboot handles system reboot command.
func (s *Server) handleReboot(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        // Check CSRF token even though we might have disabled it for testing
        // This is for realistic simulation
        <span class="cov8" title="1">if s.requireCSRF </span><span class="cov0" title="0">{
                if !s.validateCSRF(r) </span><span class="cov0" title="0">{
                        writeForbidden(w, "Invalid CSRF token")
                        return
                }</span>
        }

        // Parse request body to check for cmd=reboot
        <span class="cov8" title="1">var req struct {
                Cmd string `json:"cmd"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        <span class="cov8" title="1">if req.Cmd != "reboot" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid command")
                return
        }</span>

        // Simulate reboot success
        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{})</span>
}

// handleBackups routes backup-related requests.
func (s *Server) handleBackups(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := r.URL.Path
        parts := strings.Split(path, "/")
        var filename string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "backup" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov8" title="1">{
                        filename = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                s.handleBackupList(w, r)</span>
        case "POST":<span class="cov8" title="1">
                s.handleBackupCreate(w, r)</span>
        case "DELETE":<span class="cov8" title="1">
                if filename != "" </span><span class="cov8" title="1">{
                        s.handleBackupDelete(w, r, filename)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Filename required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleBackupList returns all backups.
func (s *Server) handleBackupList(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        backups := s.state.ListBackups()

        data := make([]interface{}, len(backups))
        for i, backup := range backups </span><span class="cov8" title="1">{
                data[i] = *backup
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleBackupCreate creates a new backup.
func (s *Server) handleBackupCreate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Generate backup filename
        now := time.Now()
        filename := fmt.Sprintf("backup_%d_%d%02d%02d_%02d%02d.unf",
                now.Unix(), now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute())

        backup := &amp;types.Backup{
                Filename: filename,
                Size:     1024 * 1024, // 1MB mock size
                Time:     now.Unix(),
                Datetime: now.Format(time.RFC3339),
        }

        s.state.AddBackup(backup)
        writeAPIResponse(w, []interface{}{*backup})
}</span>

// handleBackupDelete deletes a backup.
func (s *Server) handleBackupDelete(w http.ResponseWriter, r *http.Request, filename string) <span class="cov8" title="1">{
        s.state.DeleteBackup(filename)
        writeAPIResponse(w, []interface{}{})
}</span>

// handleAdminList returns all admin users.
func (s *Server) handleAdminList(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        admins := s.state.ListAdmins()

        data := make([]interface{}, len(admins))
        for i, admin := range admins </span><span class="cov8" title="1">{
                data[i] = *admin
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleSpeedTest initiates a speed test.
func (s *Server) handleSpeedTest(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        // Simulate speed test (immediately complete for testing)
        <span class="cov8" title="1">s.state.SimulateSpeedTest()

        writeAPIResponse(w, []interface{}{})</span>
}

// handleSpeedTestStatus returns the speed test status.
func (s *Server) handleSpeedTestStatus(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        status := s.state.GetSpeedTestStatus()
        if status == nil </span><span class="cov0" title="0">{
                // No speed test run yet
                writeAPIResponse(w, []interface{}{})
                return
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{*status})</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleTrafficRules routes traffic rule requests (v2 API).
func (s *Server) handleTrafficRules(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Extract ID if present: /v2/api/site/{site}/trafficrule/{id}
        parts := strings.Split(path, "/")
        var id string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "trafficrule" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov8" title="1">{
                        id = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleGetTrafficRule(w, r, site, id)
                }</span> else<span class="cov8" title="1"> {
                        s.handleListTrafficRules(w, r, site)
                }</span>
        case "POST":<span class="cov8" title="1">
                s.handleCreateTrafficRule(w, r, site)</span>
        case "PUT":<span class="cov8" title="1">
                if id != "" </span><span class="cov8" title="1">{
                        s.handleUpdateTrafficRule(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Traffic rule ID required for update")
                }</span>
        case "DELETE":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleDeleteTrafficRule(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "Traffic rule ID required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleListTrafficRules returns all traffic rules for a site.
func (s *Server) handleListTrafficRules(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">rules := s.state.ListTrafficRules()

        data := make([]interface{}, len(rules))
        for i, rule := range rules </span><span class="cov8" title="1">{
                data[i] = *rule
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetTrafficRule returns a specific traffic rule by ID.
func (s *Server) handleGetTrafficRule(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">rule := s.state.GetTrafficRule(id)
        if rule == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*rule})</span>
}

// handleCreateTrafficRule creates a new traffic rule.
func (s *Server) handleCreateTrafficRule(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">var rule types.TrafficRule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if rule.Name == "" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Traffic rule name is required")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if rule.ID == "" </span><span class="cov8" title="1">{
                rule.ID = generateID()
        }</span>
        <span class="cov8" title="1">rule.SiteID = site

        s.state.AddTrafficRule(&amp;rule)

        writeAPIResponse(w, []interface{}{rule})</span>
}

// handleUpdateTrafficRule updates an existing traffic rule.
// Note: PUT returns 201 for traffic rules (v2 API quirk).
func (s *Server) handleUpdateTrafficRule(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        if r.Method != "PUT" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">existing := s.state.GetTrafficRule(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">var rule types.TrafficRule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Preserve ID and site
        <span class="cov8" title="1">rule.ID = id
        rule.SiteID = site

        s.state.UpdateTrafficRule(&amp;rule)

        // Note: v2 API returns 201 for PUT operations
        writeAPIResponseWithStatus(w, []interface{}{rule}, http.StatusCreated)</span>
}

// handleDeleteTrafficRule deletes a traffic rule.
func (s *Server) handleDeleteTrafficRule(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        if r.Method != "DELETE" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov0" title="0">existing := s.state.GetTrafficRule(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteTrafficRule(id)

        writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleUsers routes user-related requests.
func (s *Server) handleUsers(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        path := r.URL.Path

        // User group endpoints
        if strings.Contains(path, "/rest/usergroup") </span><span class="cov0" title="0">{
                s.handleUserGroups(w, r, site)
                return
        }</span>

        // User endpoints: /rest/user
        <span class="cov0" title="0">if strings.Contains(path, "/rest/user") </span><span class="cov0" title="0">{
                parts := strings.Split(path, "/")
                var id string
                for i, part := range parts </span><span class="cov0" title="0">{
                        if part == "user" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov0" title="0">{
                                id = parts[i+1]
                                break</span>
                        }
                }

                <span class="cov0" title="0">switch r.Method </span>{
                case "GET":<span class="cov0" title="0">
                        if id != "" </span><span class="cov0" title="0">{
                                s.handleGetUser(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                s.handleListUsers(w, r, site)
                        }</span>
                case "POST":<span class="cov0" title="0">
                        s.handleCreateUser(w, r, site)</span>
                case "PUT":<span class="cov0" title="0">
                        if id != "" </span><span class="cov0" title="0">{
                                s.handleUpdateUser(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "User ID required for update")
                        }</span>
                case "DELETE":<span class="cov0" title="0">
                        if id != "" </span><span class="cov0" title="0">{
                                s.handleDeleteUser(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "User ID required for delete")
                        }</span>
                default:<span class="cov0" title="0">
                        writeNotFound(w)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleListUsers returns all users.
func (s *Server) handleListUsers(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        users := s.state.ListKnownClients()

        data := make([]interface{}, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                data[i] = *user
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, data)</span>
}

// handleGetUser returns a specific user by ID.
func (s *Server) handleGetUser(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        user := s.state.GetKnownClient(id)
        if user == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*user})</span>
}

// handleCreateUser creates a new user.
func (s *Server) handleCreateUser(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        var user types.User
        if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">if user.ID == "" </span><span class="cov0" title="0">{
                user.ID = generateID()
        }</span>

        // Set site ID
        <span class="cov0" title="0">if user.SiteID == "" </span><span class="cov0" title="0">{
                user.SiteID = site
        }</span>

        <span class="cov0" title="0">s.state.AddKnownClient(&amp;user)

        writeAPIResponse(w, []interface{}{user})</span>
}

// handleUpdateUser updates an existing user.
func (s *Server) handleUpdateUser(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        existing := s.state.GetKnownClient(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">var user types.User
        if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Preserve ID
        <span class="cov0" title="0">user.ID = id
        user.SiteID = site

        s.state.UpdateKnownClient(&amp;user)

        writeAPIResponse(w, []interface{}{user})</span>
}

// handleDeleteUser deletes a user.
func (s *Server) handleDeleteUser(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        user := s.state.GetKnownClient(id)
        if user == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteKnownClient(id)

        writeAPIResponse(w, []interface{}{})</span>
}

// handleUserGroups routes user group requests.
func (s *Server) handleUserGroups(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        path := r.URL.Path

        // Extract ID if present
        parts := strings.Split(path, "/")
        var id string
        for i, part := range parts </span><span class="cov0" title="0">{
                if part == "usergroup" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov0" title="0">{
                        id = parts[i+1]
                        break</span>
                }
        }

        <span class="cov0" title="0">switch r.Method </span>{
        case "GET":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleGetUserGroup(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        s.handleListUserGroups(w, r, site)
                }</span>
        case "POST":<span class="cov0" title="0">
                s.handleCreateUserGroup(w, r, site)</span>
        case "PUT":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleUpdateUserGroup(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "User group ID required for update")
                }</span>
        case "DELETE":<span class="cov0" title="0">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleDeleteUserGroup(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "User group ID required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleListUserGroups returns all user groups.
func (s *Server) handleListUserGroups(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        groups := s.state.ListUserGroups()

        data := make([]interface{}, len(groups))
        for i, group := range groups </span><span class="cov0" title="0">{
                data[i] = *group
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, data)</span>
}

// handleGetUserGroup returns a specific user group by ID.
func (s *Server) handleGetUserGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        group := s.state.GetUserGroup(id)
        if group == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*group})</span>
}

// handleCreateUserGroup creates a new user group.
func (s *Server) handleCreateUserGroup(w http.ResponseWriter, r *http.Request, site string) <span class="cov0" title="0">{
        var group types.UserGroup
        if err := json.NewDecoder(r.Body).Decode(&amp;group); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">if group.ID == "" </span><span class="cov0" title="0">{
                group.ID = generateID()
        }</span>

        // Set site ID
        <span class="cov0" title="0">if group.SiteID == "" </span><span class="cov0" title="0">{
                group.SiteID = site
        }</span>

        <span class="cov0" title="0">s.state.AddUserGroup(&amp;group)

        writeAPIResponse(w, []interface{}{group})</span>
}

// handleUpdateUserGroup updates an existing user group.
func (s *Server) handleUpdateUserGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        existing := s.state.GetUserGroup(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">var group types.UserGroup
        if err := json.NewDecoder(r.Body).Decode(&amp;group); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid request body")
                return
        }</span>

        // Preserve ID
        <span class="cov0" title="0">group.ID = id
        group.SiteID = site

        s.state.UpdateUserGroup(&amp;group)

        writeAPIResponse(w, []interface{}{group})</span>
}

// handleDeleteUserGroup deletes a user group.
func (s *Server) handleDeleteUserGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        group := s.state.GetUserGroup(id)
        if group == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">s.state.DeleteUserGroup(id)

        writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"
        "sync"

        "github.com/gorilla/websocket"
        "github.com/unifi-go/gofi/types"
)

var upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true
        }</span>,
}

type wsConnection struct {
        conn *websocket.Conn
        site string
}

// handleWebSocket handles WebSocket connections for event streaming.
func (s *Server) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract site from path
        site := extractSiteFromPath(r.URL.Path)

        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">wsConn := &amp;wsConnection{
                conn: conn,
                site: site,
        }

        s.addWebSocketConnection(wsConn)
        defer s.removeWebSocketConnection(wsConn)

        // Keep connection alive and handle messages
        for </span><span class="cov0" title="0">{
                _, _, err := conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

var (
        wsConnections   = make(map[*wsConnection]bool)
        wsConnectionsMu sync.RWMutex
)

func (s *Server) addWebSocketConnection(conn *wsConnection) <span class="cov0" title="0">{
        wsConnectionsMu.Lock()
        defer wsConnectionsMu.Unlock()
        wsConnections[conn] = true
}</span>

func (s *Server) removeWebSocketConnection(conn *wsConnection) <span class="cov0" title="0">{
        wsConnectionsMu.Lock()
        defer wsConnectionsMu.Unlock()
        delete(wsConnections, conn)
}</span>

// BroadcastEvent broadcasts an event to all connected WebSocket clients.
func (s *Server) BroadcastEvent(event *types.Event) <span class="cov0" title="0">{
        wsConnectionsMu.RLock()
        connections := make([]*wsConnection, 0, len(wsConnections))
        for conn := range wsConnections </span><span class="cov0" title="0">{
                connections = append(connections, conn)
        }</span>
        <span class="cov0" title="0">wsConnectionsMu.RUnlock()

        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, conn := range connections </span><span class="cov0" title="0">{
                // Only send to connections for the same site
                if conn.site == "" || conn.site == event.SiteID </span><span class="cov0" title="0">{
                        conn.conn.WriteMessage(websocket.TextMessage, data)
                }</span>
        }
}

// SimulateClientConnect simulates a client connection event.
func (s *Server) SimulateClientConnect(site string, client *types.Client) <span class="cov0" title="0">{
        event := &amp;types.Event{
                Key:     "EVT_WU_Connected",
                SiteID:  site,
                Time:    0,
                Message: "User connected",
        }
        s.BroadcastEvent(event)
}</span>

// SimulateClientDisconnect simulates a client disconnection event.
func (s *Server) SimulateClientDisconnect(site, mac string) <span class="cov0" title="0">{
        event := &amp;types.Event{
                Key:     "EVT_WU_Disconnected",
                SiteID:  site,
                Time:    0,
                Message: "User disconnected",
        }
        s.BroadcastEvent(event)
}</span>

// SimulateDeviceUpdate simulates a device update event.
func (s *Server) SimulateDeviceUpdate(site string, device *types.Device) <span class="cov0" title="0">{
        event := &amp;types.Event{
                Key:     "EVT_AP_Updated",
                SiteID:  site,
                Time:    0,
                Message: "Device updated",
        }
        s.BroadcastEvent(event)
}</span>

// SimulateAlarm simulates an alarm event.
func (s *Server) SimulateAlarm(site string, alarm *types.Alarm) <span class="cov0" title="0">{
        event := &amp;types.Event{
                Key:     "EVT_AD_Alarm",
                SiteID:  site,
                Time:    0,
                Message: "Alarm triggered",
        }
        s.BroadcastEvent(event)
}</span>

func extractSiteFromPath(path string) string <span class="cov0" title="0">{
        // Extract site from /proxy/network/wss/s/{site}/events
        parts := strings.Split(strings.Trim(path, "/"), "/")
        for i, part := range parts </span><span class="cov0" title="0">{
                if part == "s" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov0" title="0">{
                        return parts[i+1]
                }</span>
        }
        <span class="cov0" title="0">return "default"</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package mock

import (
        "encoding/json"
        "net/http"
        "strings"

        "github.com/unifi-go/gofi/types"
)

// handleWLANs routes WLAN-related requests.
func (s *Server) handleWLANs(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // WLAN Group endpoints: /rest/wlangroup
        if strings.Contains(path, "/rest/wlangroup") </span><span class="cov8" title="1">{
                s.handleWLANGroups(w, r, site)
                return
        }</span>

        // WLAN endpoints: /rest/wlanconf
        <span class="cov8" title="1">if strings.Contains(path, "/rest/wlanconf") </span><span class="cov8" title="1">{
                // Extract ID if present
                parts := strings.Split(path, "/")
                var id string
                for i, part := range parts </span><span class="cov8" title="1">{
                        if part == "wlanconf" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov8" title="1">{
                                id = parts[i+1]
                                break</span>
                        }
                }

                <span class="cov8" title="1">switch r.Method </span>{
                case "GET":<span class="cov8" title="1">
                        if id != "" </span><span class="cov8" title="1">{
                                s.handleGetWLAN(w, r, site, id)
                        }</span> else<span class="cov8" title="1"> {
                                s.handleListWLANs(w, r, site)
                        }</span>
                case "POST":<span class="cov8" title="1">
                        s.handleCreateWLAN(w, r, site)</span>
                case "PUT":<span class="cov8" title="1">
                        if id != "" </span><span class="cov8" title="1">{
                                s.handleUpdateWLAN(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "WLAN ID required for update")
                        }</span>
                case "DELETE":<span class="cov8" title="1">
                        if id != "" </span><span class="cov8" title="1">{
                                s.handleDeleteWLAN(w, r, site, id)
                        }</span> else<span class="cov0" title="0"> {
                                writeBadRequest(w, "WLAN ID required for delete")
                        }</span>
                default:<span class="cov0" title="0">
                        writeNotFound(w)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov0" title="0">writeNotFound(w)</span>
}

// handleListWLANs returns all WLANs for a site.
func (s *Server) handleListWLANs(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">wlans := s.state.ListWLANs()

        data := make([]interface{}, len(wlans))
        for i, wlan := range wlans </span><span class="cov8" title="1">{
                data[i] = *wlan
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetWLAN returns a specific WLAN by ID.
func (s *Server) handleGetWLAN(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">wlan := s.state.GetWLAN(id)
        if wlan == nil </span><span class="cov8" title="1">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, []interface{}{*wlan})</span>
}

// handleCreateWLAN creates a new WLAN.
func (s *Server) handleCreateWLAN(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">var wlan types.WLAN
        if err := json.NewDecoder(r.Body).Decode(&amp;wlan); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if wlan.Name == "" </span><span class="cov0" title="0">{
                writeBadRequest(w, "WLAN name is required")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if wlan.ID == "" </span><span class="cov8" title="1">{
                wlan.ID = generateID()
        }</span>
        <span class="cov8" title="1">wlan.SiteID = site

        s.state.AddWLAN(&amp;wlan)

        writeAPIResponse(w, []interface{}{wlan})</span>
}

// handleUpdateWLAN updates an existing WLAN.
func (s *Server) handleUpdateWLAN(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        if r.Method != "PUT" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">existing := s.state.GetWLAN(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">var wlan types.WLAN
        if err := json.NewDecoder(r.Body).Decode(&amp;wlan); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Preserve ID and site
        <span class="cov8" title="1">wlan.ID = id
        wlan.SiteID = site

        s.state.UpdateWLAN(&amp;wlan)

        writeAPIResponse(w, []interface{}{wlan})</span>
}

// handleDeleteWLAN deletes a WLAN.
func (s *Server) handleDeleteWLAN(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        if r.Method != "DELETE" </span><span class="cov0" title="0">{
                writeBadRequest(w, "Method not allowed")
                return
        }</span>

        <span class="cov8" title="1">existing := s.state.GetWLAN(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">s.state.DeleteWLAN(id)

        writeAPIResponse(w, []interface{}{})</span>
}

// handleWLANGroups routes WLAN group requests.
func (s *Server) handleWLANGroups(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        path := r.URL.Path

        // Extract ID if present
        parts := strings.Split(path, "/")
        var id string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "wlangroup" &amp;&amp; i+1 &lt; len(parts) &amp;&amp; parts[i+1] != "" </span><span class="cov8" title="1">{
                        id = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case "GET":<span class="cov8" title="1">
                if id != "" </span><span class="cov0" title="0">{
                        s.handleGetWLANGroup(w, r, site, id)
                }</span> else<span class="cov8" title="1"> {
                        s.handleListWLANGroups(w, r, site)
                }</span>
        case "POST":<span class="cov8" title="1">
                s.handleCreateWLANGroup(w, r, site)</span>
        case "PUT":<span class="cov8" title="1">
                if id != "" </span><span class="cov8" title="1">{
                        s.handleUpdateWLANGroup(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "WLAN group ID required for update")
                }</span>
        case "DELETE":<span class="cov8" title="1">
                if id != "" </span><span class="cov8" title="1">{
                        s.handleDeleteWLANGroup(w, r, site, id)
                }</span> else<span class="cov0" title="0"> {
                        writeBadRequest(w, "WLAN group ID required for delete")
                }</span>
        default:<span class="cov0" title="0">
                writeNotFound(w)</span>
        }
}

// handleListWLANGroups returns all WLAN groups for a site.
func (s *Server) handleListWLANGroups(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        groups := s.state.ListWLANGroups()

        data := make([]interface{}, len(groups))
        for i, group := range groups </span><span class="cov8" title="1">{
                data[i] = *group
        }</span>

        <span class="cov8" title="1">writeAPIResponse(w, data)</span>
}

// handleGetWLANGroup returns a specific WLAN group by ID.
func (s *Server) handleGetWLANGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov0" title="0">{
        group := s.state.GetWLANGroup(id)
        if group == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov0" title="0">writeAPIResponse(w, []interface{}{*group})</span>
}

// handleCreateWLANGroup creates a new WLAN group.
func (s *Server) handleCreateWLANGroup(w http.ResponseWriter, r *http.Request, site string) <span class="cov8" title="1">{
        var group types.WLANGroup
        if err := json.NewDecoder(r.Body).Decode(&amp;group); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if group.Name == "" </span><span class="cov0" title="0">{
                writeBadRequest(w, "WLAN group name is required")
                return
        }</span>

        // Generate ID if not provided
        <span class="cov8" title="1">if group.ID == "" </span><span class="cov8" title="1">{
                group.ID = generateID()
        }</span>
        <span class="cov8" title="1">group.SiteID = site

        s.state.AddWLANGroup(&amp;group)

        writeAPIResponse(w, []interface{}{group})</span>
}

// handleUpdateWLANGroup updates an existing WLAN group.
func (s *Server) handleUpdateWLANGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        existing := s.state.GetWLANGroup(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">var group types.WLANGroup
        if err := json.NewDecoder(r.Body).Decode(&amp;group); err != nil </span><span class="cov0" title="0">{
                writeBadRequest(w, "Invalid JSON")
                return
        }</span>

        // Preserve ID and site
        <span class="cov8" title="1">group.ID = id
        group.SiteID = site

        s.state.UpdateWLANGroup(&amp;group)

        writeAPIResponse(w, []interface{}{group})</span>
}

// handleDeleteWLANGroup deletes a WLAN group.
func (s *Server) handleDeleteWLANGroup(w http.ResponseWriter, r *http.Request, site, id string) <span class="cov8" title="1">{
        existing := s.state.GetWLANGroup(id)
        if existing == nil </span><span class="cov0" title="0">{
                writeNotFound(w)
                return
        }</span>

        <span class="cov8" title="1">s.state.DeleteWLANGroup(id)

        writeAPIResponse(w, []interface{}{})</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package mock

// Option configures a mock server.
type Option func(*Server)

// WithoutAuth disables authentication checks.
func WithoutAuth() Option <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov8" title="1">{
                s.requireAuth = false
        }</span>
}

// WithoutCSRF disables CSRF token checks.
func WithoutCSRF() Option <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov8" title="1">{
                s.requireCSRF = false
        }</span>
}

// WithFixtures loads fixtures into the server state.
func WithFixtures(fixtures *Fixtures) Option <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov8" title="1">{
                if fixtures != nil </span><span class="cov8" title="1">{
                        s.state.LoadFixtures(fixtures)
                }</span>
        }
}

// WithScenario applies a test scenario to the server.
func WithScenario(scenario Scenario) Option <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov8" title="1">{
                s.scenario = scenario
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package mock

import (
        "encoding/json"
        "net/http"

        "github.com/unifi-go/gofi/types"
)

// writeJSON writes a JSON response.
func writeJSON(w http.ResponseWriter, statusCode int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(data)
}</span>

// writeAPIResponse writes a successful API response with data.
func writeAPIResponse(w http.ResponseWriter, data interface{}) <span class="cov8" title="1">{
        resp := types.APIResponse[interface{}]{
                Meta: types.ResponseMeta{
                        RC: "ok",
                },
                Data: []interface{}{data},
        }

        // If data is already a slice, use it directly
        switch v := data.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                resp.Data = v</span>
        case []types.Site:<span class="cov0" title="0">
                resp.Data = make([]interface{}, len(v))
                for i, item := range v </span><span class="cov0" title="0">{
                        resp.Data[i] = item
                }</span>
        case []types.Device:<span class="cov0" title="0">
                resp.Data = make([]interface{}, len(v))
                for i, item := range v </span><span class="cov0" title="0">{
                        resp.Data[i] = item
                }</span>
        case []types.Network:<span class="cov0" title="0">
                resp.Data = make([]interface{}, len(v))
                for i, item := range v </span><span class="cov0" title="0">{
                        resp.Data[i] = item
                }</span>
        default:<span class="cov8" title="1">
                // Single item, wrap in slice
                resp.Data = []interface{}{data}</span>
        }

        <span class="cov8" title="1">resp.Meta.Count = len(resp.Data)
        writeJSON(w, http.StatusOK, resp)</span>
}

// writeAPIError writes an API error response.
func writeAPIError(w http.ResponseWriter, statusCode int, rc, message string) <span class="cov8" title="1">{
        resp := struct {
                Meta types.ResponseMeta `json:"meta"`
                Data []interface{}      `json:"data"`
        }{
                Meta: types.ResponseMeta{
                        RC:      rc,
                        Message: message,
                },
                Data: []interface{}{},
        }

        writeJSON(w, statusCode, resp)
}</span>

// writeUnauthorized writes a 401 Unauthorized response.
func writeUnauthorized(w http.ResponseWriter) <span class="cov8" title="1">{
        writeAPIError(w, http.StatusUnauthorized, "error", "unauthorized")
}</span>

// writeForbidden writes a 403 Forbidden response.
func writeForbidden(w http.ResponseWriter, message string) <span class="cov8" title="1">{
        writeAPIError(w, http.StatusForbidden, "error", message)
}</span>

// writeNotFound writes a 404 Not Found response.
func writeNotFound(w http.ResponseWriter) <span class="cov8" title="1">{
        writeAPIError(w, http.StatusNotFound, "error", "not found")
}</span>

// writeBadRequest writes a 400 Bad Request response.
func writeBadRequest(w http.ResponseWriter, message string) <span class="cov8" title="1">{
        writeAPIError(w, http.StatusBadRequest, "error", message)
}</span>

// writeAPIResponseWithStatus writes an API response with a specific status code.
func writeAPIResponseWithStatus(w http.ResponseWriter, data interface{}, statusCode int) <span class="cov8" title="1">{
        resp := types.APIResponse[interface{}]{
                Meta: types.ResponseMeta{
                        RC: "ok",
                },
                Data: []interface{}{data},
        }

        // If data is already a slice, use it directly
        if dataSlice, ok := data.([]interface{}); ok </span><span class="cov8" title="1">{
                resp.Data = dataSlice
        }</span> else<span class="cov0" title="0"> {
                resp.Data = []interface{}{data}
        }</span>

        <span class="cov8" title="1">resp.Meta.Count = len(resp.Data)
        writeJSON(w, statusCode, resp)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package mock

import "net/http"

// Scenario defines a test scenario that modifies server behavior.
type Scenario interface {
        // Apply modifies the response based on the scenario.
        Apply(w http.ResponseWriter, r *http.Request) bool
}

// ErrorScenario simulates an error condition.
type ErrorScenario struct {
        Path       string // Path to match (empty = all paths)
        StatusCode int
        RC         string
        Message    string
}

// Apply implements Scenario.
func (e *ErrorScenario) Apply(w http.ResponseWriter, r *http.Request) bool <span class="cov8" title="1">{
        // If path is specified, only apply to matching paths
        if e.Path != "" &amp;&amp; r.URL.Path != e.Path </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">writeAPIError(w, e.StatusCode, e.RC, e.Message)
        return true</span>
}

// Predefined scenarios
var (
        // ScenarioSessionExpired simulates a session expiration.
        ScenarioSessionExpired = &amp;ErrorScenario{
                StatusCode: http.StatusUnauthorized,
                RC:         "error",
                Message:    "Session expired",
        }

        // ScenarioCSRFFailure simulates a CSRF token failure.
        ScenarioCSRFFailure = &amp;ErrorScenario{
                StatusCode: http.StatusForbidden,
                RC:         "error_invalid_csrf_token",
                Message:    "Invalid CSRF token",
        }

        // ScenarioRateLimit simulates rate limiting.
        ScenarioRateLimit = &amp;ErrorScenario{
                StatusCode: http.StatusTooManyRequests,
                RC:         "error",
                Message:    "Too many requests",
        }

        // ScenarioServerError simulates a server error.
        ScenarioServerError = &amp;ErrorScenario{
                StatusCode: http.StatusInternalServerError,
                RC:         "error",
                Message:    "Internal server error",
        }
)
</pre>
		
		<pre class="file" id="file32" style="display: none">package mock

import (
        "crypto/rand"
        "crypto/tls"
        "encoding/hex"
        "net"
        "net/http"
        "net/http/httptest"
        "strconv"
        "strings"
)

// Server is a mock UniFi controller server.
type Server struct {
        server      *httptest.Server
        state       *State
        requireAuth bool
        requireCSRF bool
        scenario    Scenario
}

// NewServer creates a new mock server.
func NewServer(opts ...Option) *Server <span class="cov8" title="1">{
        s := &amp;Server{
                state:       NewState(),
                requireAuth: true,
                requireCSRF: true,
        }

        // Apply options
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(s)
        }</span>

        // Create HTTP server with TLS
        <span class="cov8" title="1">s.server = httptest.NewUnstartedServer(s)
        s.server.TLS = &amp;tls.Config{
                InsecureSkipVerify: true,
        }
        s.server.StartTLS()

        return s</span>
}

// ServeHTTP implements http.Handler.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Apply scenario if set
        if s.scenario != nil </span><span class="cov0" title="0">{
                if s.scenario.Apply(w, r) </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Route requests
        <span class="cov8" title="1">path := r.URL.Path

        // Auth endpoints (no auth required)
        if path == "/api/auth/login" </span><span class="cov8" title="1">{
                s.handleLogin(w, r)
                return
        }</span>

        <span class="cov8" title="1">if path == "/api/logout" </span><span class="cov8" title="1">{
                s.handleLogout(w, r)
                return
        }</span>

        <span class="cov8" title="1">if path == "/api/status" </span><span class="cov8" title="1">{
                s.handleStatus(w, r)
                return
        }</span>

        // All other endpoints require authentication
        <span class="cov8" title="1">if s.requireAuth </span><span class="cov8" title="1">{
                if !s.isAuthenticated(r) </span><span class="cov8" title="1">{
                        writeUnauthorized(w)
                        return
                }</span>
        }

        // Check CSRF token for non-GET requests
        <span class="cov8" title="1">if s.requireCSRF &amp;&amp; r.Method != "GET" &amp;&amp; r.Method != "HEAD" </span><span class="cov0" title="0">{
                if !s.validateCSRF(r) </span><span class="cov0" title="0">{
                        writeForbidden(w, "Invalid CSRF token")
                        return
                }</span>
        }

        <span class="cov8" title="1">if path == "/api/self" </span><span class="cov8" title="1">{
                s.handleSelf(w, r)
                return
        }</span>

        // Extract site from path for API calls
        <span class="cov8" title="1">site := ""
        parts := strings.Split(path, "/")
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "s" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov8" title="1">{
                        site = parts[i+1]
                        break</span>
                }
        }

        // Device endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/stat/device") ||
           strings.Contains(path, "/basicstat/device") ||
           (strings.Contains(path, "/rest/device/") &amp;&amp; r.Method == "PUT") ||
           strings.Contains(path, "/cmd/devmgr") </span><span class="cov8" title="1">{
                s.handleDevices(w, r, site)
                return
        }</span>

        // Network endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/rest/networkconf") </span><span class="cov0" title="0">{
                s.handleNetworks(w, r, site)
                return
        }</span>

        // WLAN endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/rest/wlanconf") || strings.Contains(path, "/rest/wlangroup") </span><span class="cov8" title="1">{
                s.handleWLANs(w, r, site)
                return
        }</span>

        // Firewall endpoints (v1 API)
        <span class="cov8" title="1">if strings.Contains(path, "/rest/firewallrule") || strings.Contains(path, "/rest/firewallgroup") </span><span class="cov8" title="1">{
                s.handleFirewall(w, r, site)
                return
        }</span>

        // Traffic rules (v2 API)
        <span class="cov8" title="1">if strings.Contains(path, "/v2/api/site/") &amp;&amp; strings.Contains(path, "/trafficrule") </span><span class="cov8" title="1">{
                s.handleTrafficRules(w, r, site)
                return
        }</span>

        // Client/station endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/stat/sta") || strings.Contains(path, "/stat/alluser") || strings.Contains(path, "/cmd/stamgr") </span><span class="cov8" title="1">{
                s.handleClients(w, r, site)
                return
        }</span>

        // User/known client endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/rest/user") </span><span class="cov0" title="0">{
                s.handleUsers(w, r, site)
                return
        }</span>

        // Routing endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/rest/routing") </span><span class="cov8" title="1">{
                s.handleRouting(w, r, site)
                return
        }</span>

        // Port forwarding and port profile endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/rest/portforward") || strings.Contains(path, "/rest/portconf") </span><span class="cov8" title="1">{
                s.handlePorts(w, r, site)
                return
        }</span>

        // Settings endpoints
        <span class="cov8" title="1">if strings.Contains(path, "/rest/setting") || strings.Contains(path, "/rest/radiusprofile") || strings.Contains(path, "/rest/dynamicdns") </span><span class="cov8" title="1">{
                s.handleSettings(w, r, site)
                return
        }</span>

        // System endpoints (reboot, backup, admin, speedtest)
        <span class="cov8" title="1">if strings.Contains(path, "/api/cmd/system") || strings.Contains(path, "/api/cmd/backup") ||
           strings.Contains(path, "/api/stat/admin") || strings.Contains(path, "/cmd/speedtest") ||
           strings.Contains(path, "/stat/speedtest") </span><span class="cov8" title="1">{
                s.handleSystem(w, r, site)
                return
        }</span>

        // Site endpoints
        <span class="cov8" title="1">if strings.HasPrefix(path, "/api/self/sites") ||
           strings.Contains(path, "/api/s/") ||
           strings.Contains(path, "/stat/health") ||
           strings.Contains(path, "/stat/sysinfo") </span><span class="cov8" title="1">{
                s.handleSites(w, r, "")
                return
        }</span>

        // Default: 404
        <span class="cov8" title="1">writeNotFound(w)</span>
}

// Close shuts down the server.
func (s *Server) Close() <span class="cov8" title="1">{
        if s.server != nil </span><span class="cov8" title="1">{
                s.server.Close()
        }</span>
}

// URL returns the server's base URL.
func (s *Server) URL() string <span class="cov8" title="1">{
        if s.server != nil </span><span class="cov8" title="1">{
                return s.server.URL
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Host returns the server's host (without scheme).
func (s *Server) Host() string <span class="cov0" title="0">{
        if s.server != nil </span><span class="cov0" title="0">{
                host, _, _ := net.SplitHostPort(s.server.Listener.Addr().String())
                return host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Port returns the server's port.
func (s *Server) Port() int <span class="cov0" title="0">{
        if s.server != nil </span><span class="cov0" title="0">{
                _, port, _ := net.SplitHostPort(s.server.Listener.Addr().String())
                // Port is a string, parse it
                if p, err := strconv.Atoi(port); err == nil </span><span class="cov0" title="0">{
                        return p
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// State returns the server's state (for test manipulation).
func (s *Server) State() *State <span class="cov8" title="1">{
        return s.state
}</span>

// isAuthenticated checks if the request has a valid session.
func (s *Server) isAuthenticated(r *http.Request) bool <span class="cov8" title="1">{
        // Check for session cookie
        cookie, err := r.Cookie("unifises")
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">_, exists := s.state.GetSession(cookie.Value)
        return exists</span>
}

// validateCSRF validates the CSRF token.
func (s *Server) validateCSRF(r *http.Request) bool <span class="cov0" title="0">{
        // Get CSRF token from header
        token := r.Header.Get("X-CSRF-Token")
        if token == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get session
        <span class="cov0" title="0">cookie, err := r.Cookie("unifises")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">session, exists := s.state.GetSession(cookie.Value)
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return session.CSRFToken == token</span>
}

// generateToken generates a random session token.
func generateToken() string <span class="cov8" title="1">{
        b := make([]byte, 16)
        rand.Read(b)
        return hex.EncodeToString(b)
}</span>

// generateCSRFToken generates a random CSRF token.
func generateCSRFToken() string <span class="cov8" title="1">{
        b := make([]byte, 32)
        rand.Read(b)
        return hex.EncodeToString(b)
}</span>

// generateID generates a random ID for resources.
func generateID() string <span class="cov8" title="1">{
        b := make([]byte, 12)
        rand.Read(b)
        return hex.EncodeToString(b)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package mock

import (
        "sync"

        "github.com/unifi-go/gofi/types"
)

// State holds the mock server's in-memory state.
type State struct {
        mu sync.RWMutex

        // Authentication state
        authenticatedUsers map[string]string // username -&gt; password
        sessions           map[string]*Session

        // Data stores
        sites        map[string]*types.Site
        devices      map[string]*types.Device
        networks     map[string]*types.Network
        wlans        map[string]*types.WLAN
        wlanGroups   map[string]*types.WLANGroup
        firewallRules map[string]*types.FirewallRule
        firewallGroups map[string]*types.FirewallGroup
        trafficRules map[string]*types.TrafficRule
        clients      map[string]*types.Client
        users        map[string]*types.User
        userGroups   map[string]*types.UserGroup
        routes         map[string]*types.Route
        portForwards   map[string]*types.PortForward
        portProfiles   map[string]*types.PortProfile
        settings         map[string]*types.Setting
        radiusProfiles   map[string]*types.RADIUSProfile
        dynamicDNS       *types.DynamicDNS
        backups          []*types.Backup
        admins           []*types.AdminUser
        speedTestStatus  *types.SpeedTestStatus
}

// Session represents a mock authentication session.
type Session struct {
        Username  string
        CSRFToken string
}

// NewState creates a new mock state.
func NewState() *State <span class="cov8" title="1">{
        s := &amp;State{
                authenticatedUsers: make(map[string]string),
                sessions:           make(map[string]*Session),
                sites:              make(map[string]*types.Site),
                devices:            make(map[string]*types.Device),
                networks:           make(map[string]*types.Network),
                wlans:              make(map[string]*types.WLAN),
                wlanGroups:         make(map[string]*types.WLANGroup),
                firewallRules:      make(map[string]*types.FirewallRule),
                firewallGroups:     make(map[string]*types.FirewallGroup),
                trafficRules:       make(map[string]*types.TrafficRule),
                clients:            make(map[string]*types.Client),
                users:              make(map[string]*types.User),
                userGroups:         make(map[string]*types.UserGroup),
                routes:             make(map[string]*types.Route),
                portForwards:       make(map[string]*types.PortForward),
                portProfiles:       make(map[string]*types.PortProfile),
                settings:           make(map[string]*types.Setting),
                radiusProfiles:     make(map[string]*types.RADIUSProfile),
                backups:            make([]*types.Backup, 0),
                admins:             make([]*types.AdminUser, 0),
        }

        // Add default admin user
        s.authenticatedUsers["admin"] = "admin"

        // Add default site
        s.sites["default"] = &amp;types.Site{
                ID:   "default",
                Name: "default",
                Desc: "Default Site",
        }

        return s
}</span>

// Reset clears all state.
func (s *State) Reset() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.sessions = make(map[string]*Session)
        s.sites = make(map[string]*types.Site)
        s.devices = make(map[string]*types.Device)
        s.networks = make(map[string]*types.Network)
        s.wlans = make(map[string]*types.WLAN)
        s.wlanGroups = make(map[string]*types.WLANGroup)
        s.firewallRules = make(map[string]*types.FirewallRule)
        s.firewallGroups = make(map[string]*types.FirewallGroup)
        s.trafficRules = make(map[string]*types.TrafficRule)
        s.clients = make(map[string]*types.Client)
        s.users = make(map[string]*types.User)
        s.userGroups = make(map[string]*types.UserGroup)
        s.routes = make(map[string]*types.Route)
        s.portForwards = make(map[string]*types.PortForward)
        s.portProfiles = make(map[string]*types.PortProfile)
        s.settings = make(map[string]*types.Setting)
        s.radiusProfiles = make(map[string]*types.RADIUSProfile)
        s.dynamicDNS = nil
        s.backups = make([]*types.Backup, 0)
        s.admins = make([]*types.AdminUser, 0)
        s.speedTestStatus = nil

        // Re-add default site
        s.sites["default"] = &amp;types.Site{
                ID:   "default",
                Name: "default",
                Desc: "Default Site",
        }
}</span>

// AddUser adds a user for authentication.
func (s *State) AddUser(username, password string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.authenticatedUsers[username] = password
}</span>

// ValidateCredentials checks if credentials are valid.
func (s *State) ValidateCredentials(username, password string) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        storedPassword, exists := s.authenticatedUsers[username]
        return exists &amp;&amp; storedPassword == password
}</span>

// CreateSession creates a new session.
func (s *State) CreateSession(token string, session *Session) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.sessions[token] = session
}</span>

// GetSession retrieves a session.
func (s *State) GetSession(token string) (*Session, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        session, exists := s.sessions[token]
        return session, exists
}</span>

// DeleteSession removes a session.
func (s *State) DeleteSession(token string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.sessions, token)
}</span>

// Site accessors
func (s *State) GetSite(id string) (*types.Site, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        site, exists := s.sites[id]
        return site, exists
}</span>

func (s *State) ListSites() []*types.Site <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        sites := make([]*types.Site, 0, len(s.sites))
        for _, site := range s.sites </span><span class="cov8" title="1">{
                sites = append(sites, site)
        }</span>
        <span class="cov8" title="1">return sites</span>
}

func (s *State) AddSite(site *types.Site) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.sites[site.ID] = site
}</span>

func (s *State) DeleteSite(id string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.sites, id)
}</span>

// Device accessors
func (s *State) GetDevice(id string) (*types.Device, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        device, exists := s.devices[id]
        return device, exists
}</span>

func (s *State) ListDevices() []*types.Device <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        devices := make([]*types.Device, 0, len(s.devices))
        for _, device := range s.devices </span><span class="cov8" title="1">{
                devices = append(devices, device)
        }</span>
        <span class="cov8" title="1">return devices</span>
}

func (s *State) AddDevice(device *types.Device) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.devices[device.ID] = device
}</span>

func (s *State) DeleteDevice(id string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.devices, id)
}</span>

// Network accessors
func (s *State) GetNetwork(id string) (*types.Network, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        network, exists := s.networks[id]
        return network, exists
}</span>

func (s *State) ListNetworks() []*types.Network <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        networks := make([]*types.Network, 0, len(s.networks))
        for _, network := range s.networks </span><span class="cov8" title="1">{
                networks = append(networks, network)
        }</span>
        <span class="cov8" title="1">return networks</span>
}

func (s *State) AddNetwork(network *types.Network) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.networks[network.ID] = network
}</span>

func (s *State) DeleteNetwork(id string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.networks, id)
}</span>

// WLAN accessors
func (s *State) GetWLAN(id string) *types.WLAN <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.wlans[id]
}</span>

func (s *State) ListWLANs() []*types.WLAN <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        wlans := make([]*types.WLAN, 0, len(s.wlans))
        for _, wlan := range s.wlans </span><span class="cov8" title="1">{
                wlans = append(wlans, wlan)
        }</span>
        <span class="cov8" title="1">return wlans</span>
}

func (s *State) AddWLAN(wlan *types.WLAN) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.wlans[wlan.ID] = wlan
}</span>

func (s *State) UpdateWLAN(wlan *types.WLAN) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.wlans[wlan.ID] = wlan
}</span>

func (s *State) DeleteWLAN(id string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.wlans, id)
}</span>

// WLAN Group accessors
func (s *State) GetWLANGroup(id string) *types.WLANGroup <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.wlanGroups[id]
}</span>

func (s *State) ListWLANGroups() []*types.WLANGroup <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        groups := make([]*types.WLANGroup, 0, len(s.wlanGroups))
        for _, group := range s.wlanGroups </span><span class="cov8" title="1">{
                groups = append(groups, group)
        }</span>
        <span class="cov8" title="1">return groups</span>
}

func (s *State) AddWLANGroup(group *types.WLANGroup) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.wlanGroups[group.ID] = group
}</span>

func (s *State) UpdateWLANGroup(group *types.WLANGroup) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.wlanGroups[group.ID] = group
}</span>

func (s *State) DeleteWLANGroup(id string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.wlanGroups, id)
}</span>

// Firewall Rule accessors
func (s *State) GetFirewallRule(id string) *types.FirewallRule <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.firewallRules[id]
}</span>

func (s *State) ListFirewallRules() []*types.FirewallRule <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        rules := make([]*types.FirewallRule, 0, len(s.firewallRules))
        for _, rule := range s.firewallRules </span><span class="cov8" title="1">{
                rules = append(rules, rule)
        }</span>
        <span class="cov8" title="1">return rules</span>
}

func (s *State) AddFirewallRule(rule *types.FirewallRule) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.firewallRules[rule.ID] = rule
}</span>

func (s *State) UpdateFirewallRule(rule *types.FirewallRule) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.firewallRules[rule.ID] = rule
}</span>

func (s *State) DeleteFirewallRule(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.firewallRules, id)
}</span>

// Firewall Group accessors
func (s *State) GetFirewallGroup(id string) *types.FirewallGroup <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.firewallGroups[id]
}</span>

func (s *State) ListFirewallGroups() []*types.FirewallGroup <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        groups := make([]*types.FirewallGroup, 0, len(s.firewallGroups))
        for _, group := range s.firewallGroups </span><span class="cov8" title="1">{
                groups = append(groups, group)
        }</span>
        <span class="cov8" title="1">return groups</span>
}

func (s *State) AddFirewallGroup(group *types.FirewallGroup) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.firewallGroups[group.ID] = group
}</span>

func (s *State) UpdateFirewallGroup(group *types.FirewallGroup) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.firewallGroups[group.ID] = group
}</span>

func (s *State) DeleteFirewallGroup(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.firewallGroups, id)
}</span>

// Traffic Rule accessors
func (s *State) GetTrafficRule(id string) *types.TrafficRule <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.trafficRules[id]
}</span>

func (s *State) ListTrafficRules() []*types.TrafficRule <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        rules := make([]*types.TrafficRule, 0, len(s.trafficRules))
        for _, rule := range s.trafficRules </span><span class="cov8" title="1">{
                rules = append(rules, rule)
        }</span>
        <span class="cov8" title="1">return rules</span>
}

func (s *State) AddTrafficRule(rule *types.TrafficRule) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.trafficRules[rule.ID] = rule
}</span>

func (s *State) UpdateTrafficRule(rule *types.TrafficRule) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.trafficRules[rule.ID] = rule
}</span>

func (s *State) DeleteTrafficRule(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.trafficRules, id)
}</span>

// Client accessors
func (s *State) GetClient(mac string) *types.Client <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.clients[mac]
}</span>

func (s *State) ListClients() []*types.Client <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        clients := make([]*types.Client, 0, len(s.clients))
        for _, client := range s.clients </span><span class="cov8" title="1">{
                clients = append(clients, client)
        }</span>
        <span class="cov8" title="1">return clients</span>
}

func (s *State) AddClient(client *types.Client) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.clients[client.MAC] = client
}</span>

func (s *State) UpdateClient(client *types.Client) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.clients[client.MAC] = client
}</span>

func (s *State) DeleteClient(mac string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.clients, mac)
}</span>

// User accessors (known clients, not auth users)
func (s *State) GetKnownClient(id string) *types.User <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.users[id]
}</span>

func (s *State) GetKnownClientByMAC(mac string) *types.User <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        for _, user := range s.users </span><span class="cov0" title="0">{
                if user.MAC == mac </span><span class="cov0" title="0">{
                        return user
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *State) ListKnownClients() []*types.User <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        users := make([]*types.User, 0, len(s.users))
        for _, user := range s.users </span><span class="cov0" title="0">{
                users = append(users, user)
        }</span>
        <span class="cov0" title="0">return users</span>
}

func (s *State) AddKnownClient(user *types.User) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[user.ID] = user
}</span>

func (s *State) UpdateKnownClient(user *types.User) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[user.ID] = user
}</span>

func (s *State) DeleteKnownClient(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.users, id)
}</span>

// UserGroup accessors
func (s *State) GetUserGroup(id string) *types.UserGroup <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.userGroups[id]
}</span>

func (s *State) ListUserGroups() []*types.UserGroup <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        groups := make([]*types.UserGroup, 0, len(s.userGroups))
        for _, group := range s.userGroups </span><span class="cov0" title="0">{
                groups = append(groups, group)
        }</span>
        <span class="cov0" title="0">return groups</span>
}

func (s *State) AddUserGroup(group *types.UserGroup) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.userGroups[group.ID] = group
}</span>

func (s *State) UpdateUserGroup(group *types.UserGroup) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.userGroups[group.ID] = group
}</span>

func (s *State) DeleteUserGroup(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.userGroups, id)
}</span>

// Route accessors
func (s *State) GetRoute(id string) *types.Route <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.routes[id]
}</span>

func (s *State) ListRoutes() []*types.Route <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        routes := make([]*types.Route, 0, len(s.routes))
        for _, route := range s.routes </span><span class="cov8" title="1">{
                routes = append(routes, route)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

func (s *State) AddRoute(route *types.Route) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.routes[route.ID] = route
}</span>

func (s *State) UpdateRoute(route *types.Route) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.routes[route.ID] = route
}</span>

func (s *State) DeleteRoute(id string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.routes, id)
}</span>

// PortForward accessors
func (s *State) GetPortForward(id string) *types.PortForward <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.portForwards[id]
}</span>

func (s *State) ListPortForwards() []*types.PortForward <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        forwards := make([]*types.PortForward, 0, len(s.portForwards))
        for _, forward := range s.portForwards </span><span class="cov8" title="1">{
                forwards = append(forwards, forward)
        }</span>
        <span class="cov8" title="1">return forwards</span>
}

func (s *State) AddPortForward(forward *types.PortForward) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.portForwards[forward.ID] = forward
}</span>

func (s *State) UpdatePortForward(forward *types.PortForward) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.portForwards[forward.ID] = forward
}</span>

func (s *State) DeletePortForward(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.portForwards, id)
}</span>

// PortProfile accessors
func (s *State) GetPortProfile(id string) *types.PortProfile <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.portProfiles[id]
}</span>

func (s *State) ListPortProfiles() []*types.PortProfile <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        profiles := make([]*types.PortProfile, 0, len(s.portProfiles))
        for _, profile := range s.portProfiles </span><span class="cov8" title="1">{
                profiles = append(profiles, profile)
        }</span>
        <span class="cov8" title="1">return profiles</span>
}

func (s *State) AddPortProfile(profile *types.PortProfile) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.portProfiles[profile.ID] = profile
}</span>

func (s *State) UpdatePortProfile(profile *types.PortProfile) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.portProfiles[profile.ID] = profile
}</span>

func (s *State) DeletePortProfile(id string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.portProfiles, id)
}</span>

// Setting accessors
func (s *State) GetSetting(key string) *types.Setting <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.settings[key]
}</span>

func (s *State) ListSettings() []*types.Setting <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        settings := make([]*types.Setting, 0, len(s.settings))
        for _, setting := range s.settings </span><span class="cov0" title="0">{
                settings = append(settings, setting)
        }</span>
        <span class="cov0" title="0">return settings</span>
}

func (s *State) AddSetting(setting *types.Setting) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.settings[setting.Key] = setting
}</span>

func (s *State) UpdateSetting(setting *types.Setting) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.settings[setting.Key] = setting
}</span>

func (s *State) DeleteSetting(key string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.settings, key)
}</span>

// RADIUSProfile accessors
func (s *State) GetRADIUSProfile(id string) *types.RADIUSProfile <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.radiusProfiles[id]
}</span>

func (s *State) ListRADIUSProfiles() []*types.RADIUSProfile <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        profiles := make([]*types.RADIUSProfile, 0, len(s.radiusProfiles))
        for _, profile := range s.radiusProfiles </span><span class="cov8" title="1">{
                profiles = append(profiles, profile)
        }</span>
        <span class="cov8" title="1">return profiles</span>
}

func (s *State) AddRADIUSProfile(profile *types.RADIUSProfile) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.radiusProfiles[profile.ID] = profile
}</span>

func (s *State) UpdateRADIUSProfile(profile *types.RADIUSProfile) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.radiusProfiles[profile.ID] = profile
}</span>

func (s *State) DeleteRADIUSProfile(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.radiusProfiles, id)
}</span>

// DynamicDNS accessors
func (s *State) GetDynamicDNS() *types.DynamicDNS <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.dynamicDNS
}</span>

func (s *State) SetDynamicDNS(ddns *types.DynamicDNS) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.dynamicDNS = ddns
}</span>

// Backup accessors
func (s *State) ListBackups() []*types.Backup <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.backups
}</span>

func (s *State) AddBackup(backup *types.Backup) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.backups = append(s.backups, backup)
}</span>

func (s *State) DeleteBackup(filename string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        for i, backup := range s.backups </span><span class="cov8" title="1">{
                if backup.Filename == filename </span><span class="cov8" title="1">{
                        s.backups = append(s.backups[:i], s.backups[i+1:]...)
                        return
                }</span>
        }
}

// Admin accessors
func (s *State) ListAdmins() []*types.AdminUser <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.admins
}</span>

func (s *State) AddAdmin(admin *types.AdminUser) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.admins = append(s.admins, admin)
}</span>

// SpeedTest accessors
func (s *State) GetSpeedTestStatus() *types.SpeedTestStatus <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.speedTestStatus
}</span>

func (s *State) SetSpeedTestStatus(status *types.SpeedTestStatus) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.speedTestStatus = status
}</span>

func (s *State) SimulateSpeedTest() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        // Simulate a completed speed test
        s.speedTestStatus = &amp;types.SpeedTestStatus{
                StatusDownload: 100,
                StatusLatency:  100,
                StatusUpload:   100,
                StatusSummary:  100,
                Latency:        15,
                Running:        false,
                Runtime:        0,
                ServerName:     "Mock Speed Test Server",
                ServerCountry:  "US",
        }
        // Set upload/download speeds
        s.speedTestStatus.XputDownload.Val = 500.0
        s.speedTestStatus.XputUpload.Val = 50.0
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package gofi

import (
        "crypto/tls"
        "time"
)

// Option configures a Client.
type Option func(*Config)

// WithTimeout sets the request timeout.
func WithTimeout(timeout time.Duration) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Timeout = timeout
        }</span>
}

// WithRetry configures retry behavior.
func WithRetry(maxRetries int, initialBackoff time.Duration) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                if c.RetryConfig == nil </span><span class="cov8" title="1">{
                        c.RetryConfig = &amp;RetryConfig{}
                }</span>
                <span class="cov8" title="1">c.RetryConfig.MaxRetries = maxRetries
                c.RetryConfig.InitialBackoff = initialBackoff
                if c.RetryConfig.MaxBackoff == 0 </span><span class="cov8" title="1">{
                        c.RetryConfig.MaxBackoff = 5 * time.Second
                }</span>
        }
}

// WithLogger sets a custom logger.
func WithLogger(logger Logger) Option <span class="cov0" title="0">{
        return func(c *Config) </span><span class="cov0" title="0">{
                c.Logger = logger
        }</span>
}

// WithTLSConfig sets custom TLS configuration.
func WithTLSConfig(tlsConfig *tls.Config) Option <span class="cov0" title="0">{
        return func(c *Config) </span><span class="cov0" title="0">{
                c.TLSConfig = tlsConfig
        }</span>
}

// WithInsecureSkipVerify disables TLS certificate verification.
// WARNING: This is insecure and should only be used for testing.
func WithInsecureSkipVerify() Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.SkipTLSVerify = true
        }</span>
}

// WithSite sets the default site.
func WithSite(site string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Site = site
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package services

import (
        "context"
        "fmt"
        "strconv"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// clientStationService implements ClientService.
type clientStationService struct {
        transport transport.Transport
}

// NewClientService creates a new client service.
func NewClientService(transport transport.Transport) ClientService <span class="cov8" title="1">{
        return &amp;clientStationService{
                transport: transport,
        }
}</span>

// ListActive returns all currently connected clients.
func (s *clientStationService) ListActive(ctx context.Context, site string) ([]types.Client, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/api/s/%s/stat/sta", site)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list active clients: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list active clients failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Client](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// ListAll returns all known clients (including historical).
func (s *clientStationService) ListAll(ctx context.Context, site string, opts ...ClientListOption) ([]types.Client, error) <span class="cov8" title="1">{
        options := &amp;clientListOptions{
                withinHours: 8760, // Default: 1 year
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(options)
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("/api/s/%s/stat/alluser", site)
        if options.withinHours &gt; 0 </span><span class="cov8" title="1">{
                path += "?within=" + strconv.Itoa(options.withinHours)
        }</span>

        <span class="cov8" title="1">req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list all clients: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list all clients failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Client](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a client by MAC address.
func (s *clientStationService) Get(ctx context.Context, site, mac string) (*types.Client, error) <span class="cov8" title="1">{
        // Get all active clients and find the one with matching MAC
        clients, err := s.ListActive(ctx, site)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, client := range clients </span><span class="cov8" title="1">{
                if client.MAC == mac </span><span class="cov8" title="1">{
                        return &amp;client, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("client not found: %s", mac)</span>
}

// Block blocks a client from the network.
func (s *clientStationService) Block(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.executeCommand(ctx, site, "block-sta", mac, nil)
}</span>

// Unblock unblocks a previously blocked client.
func (s *clientStationService) Unblock(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.executeCommand(ctx, site, "unblock-sta", mac, nil)
}</span>

// Kick disconnects a client from the network.
func (s *clientStationService) Kick(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.executeCommand(ctx, site, "kick-sta", mac, nil)
}</span>

// AuthorizeGuest authorizes a guest client.
func (s *clientStationService) AuthorizeGuest(ctx context.Context, site, mac string, opts ...GuestAuthOption) error <span class="cov8" title="1">{
        options := &amp;guestAuthOptions{}
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(options)
        }</span>

        <span class="cov8" title="1">payload := map[string]interface{}{
                "cmd": "authorize-guest",
                "mac": mac,
        }

        if options.minutes &gt; 0 </span><span class="cov8" title="1">{
                payload["minutes"] = options.minutes
        }</span>
        <span class="cov8" title="1">if options.up &gt; 0 </span><span class="cov8" title="1">{
                payload["up"] = options.up
        }</span>
        <span class="cov8" title="1">if options.down &gt; 0 </span><span class="cov8" title="1">{
                payload["down"] = options.down
        }</span>
        <span class="cov8" title="1">if options.bytes &gt; 0 </span><span class="cov0" title="0">{
                payload["bytes"] = options.bytes
        }</span>
        <span class="cov8" title="1">if options.apMAC != "" </span><span class="cov0" title="0">{
                payload["ap_mac"] = options.apMAC
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("/api/s/%s/cmd/stamgr", site)
        req := transport.NewRequest("POST", path).WithBody(payload)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to authorize guest: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("authorize guest failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UnauthorizeGuest revokes guest authorization.
func (s *clientStationService) UnauthorizeGuest(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.executeCommand(ctx, site, "unauthorize-guest", mac, nil)
}</span>

// Forget removes a client from the known clients list.
func (s *clientStationService) Forget(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.executeCommand(ctx, site, "forget-sta", mac, nil)
}</span>

// SetFingerprint overrides the device fingerprint.
func (s *clientStationService) SetFingerprint(ctx context.Context, site, mac string, devID int) error <span class="cov8" title="1">{
        payload := map[string]interface{}{
                "dev_id": devID,
        }
        return s.executeCommand(ctx, site, "set-sta-dev-id", mac, payload)
}</span>

// executeCommand executes a client management command.
func (s *clientStationService) executeCommand(ctx context.Context, site, cmd, mac string, extra map[string]interface{}) error <span class="cov8" title="1">{
        payload := map[string]interface{}{
                "cmd": cmd,
                "mac": mac,
        }

        // Merge extra fields
        for k, v := range extra </span><span class="cov8" title="1">{
                payload[k] = v
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("/api/s/%s/cmd/stamgr", site)
        req := transport.NewRequest("POST", path).WithBody(payload)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute client command %s: %w", cmd, err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("client command %s failed with status %d", cmd, resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// deviceService implements DeviceService.
type deviceService struct {
        transport transport.Transport
}

// NewDeviceService creates a new device service.
func NewDeviceService(transport transport.Transport) DeviceService <span class="cov8" title="1">{
        return &amp;deviceService{
                transport: transport,
        }
}</span>

// List returns all devices for a site.
func (s *deviceService) List(ctx context.Context, site string) ([]types.Device, error) <span class="cov8" title="1">{
        path := internal.BuildAPIPath(site, "stat/device")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list devices: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list devices failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Device](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// ListBasic returns basic device information for faster queries.
func (s *deviceService) ListBasic(ctx context.Context, site string) ([]types.DeviceBasic, error) <span class="cov8" title="1">{
        path := internal.BuildAPIPath(site, "basicstat/device")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list basic devices: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list basic devices failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.DeviceBasic](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a specific device by ID.
func (s *deviceService) Get(ctx context.Context, site, id string) (*types.Device, error) <span class="cov8" title="1">{
        devices, err := s.List(ctx, site)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, device := range devices </span><span class="cov8" title="1">{
                if device.ID == id </span><span class="cov8" title="1">{
                        return &amp;device, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("device not found: %s", id)</span>
}

// GetByMAC returns a specific device by MAC address.
func (s *deviceService) GetByMAC(ctx context.Context, site, mac string) (*types.Device, error) <span class="cov8" title="1">{
        devices, err := s.List(ctx, site)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Normalize MAC for comparison
        <span class="cov8" title="1">normalizedMAC := strings.ToLower(strings.ReplaceAll(mac, ":", ""))

        for _, device := range devices </span><span class="cov8" title="1">{
                deviceMAC := strings.ToLower(strings.ReplaceAll(device.MAC, ":", ""))
                if deviceMAC == normalizedMAC </span><span class="cov8" title="1">{
                        return &amp;device, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("device not found with MAC: %s", mac)</span>
}

// Update updates a device's configuration.
func (s *deviceService) Update(ctx context.Context, site string, device *types.Device) (*types.Device, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "device", device.ID)
        req := transport.NewRequest("PUT", path).WithBody(device)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update device: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update device failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">updated, err := internal.ParseSingleResult[types.Device](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return updated, nil</span>
}

// Adopt adopts a device into the controller.
func (s *deviceService) Adopt(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "adopt", mac, nil)
}</span>

// Forget removes a device from the controller.
func (s *deviceService) Forget(ctx context.Context, site, mac string) error <span class="cov0" title="0">{
        return s.sendCommand(ctx, site, "forget", mac, nil)
}</span>

// Restart restarts a device.
func (s *deviceService) Restart(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "restart", mac, nil)
}</span>

// ForceProvision forces provisioning of a device.
func (s *deviceService) ForceProvision(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "force-provision", mac, nil)
}</span>

// Upgrade upgrades a device to the latest firmware.
func (s *deviceService) Upgrade(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "upgrade", mac, nil)
}</span>

// UpgradeExternal upgrades a device using an external firmware URL.
func (s *deviceService) UpgradeExternal(ctx context.Context, site, mac, url string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "upgrade-external", mac, map[string]interface{}{
                "url": url,
        })
}</span>

// Locate enables the locate LED on a device.
func (s *deviceService) Locate(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "set-locate", mac, nil)
}</span>

// Unlocate disables the locate LED on a device.
func (s *deviceService) Unlocate(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "unset-locate", mac, nil)
}</span>

// PowerCyclePort power cycles a specific port on a switch.
func (s *deviceService) PowerCyclePort(ctx context.Context, site, switchMAC string, portIdx int) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "power-cycle", switchMAC, map[string]interface{}{
                "port_idx": portIdx,
        })
}</span>

// SetLEDOverride sets the LED override mode for a device.
func (s *deviceService) SetLEDOverride(ctx context.Context, site, mac, mode string) error <span class="cov0" title="0">{
        return s.sendCommand(ctx, site, "set-led-override", mac, map[string]interface{}{
                "mode": mode,
        })
}</span>

// SpectrumScan initiates a spectrum scan on an AP.
func (s *deviceService) SpectrumScan(ctx context.Context, site, mac string) error <span class="cov8" title="1">{
        return s.sendCommand(ctx, site, "spectrum-scan", mac, nil)
}</span>

// sendCommand sends a device command.
func (s *deviceService) sendCommand(ctx context.Context, site, cmd, mac string, params map[string]interface{}) error <span class="cov8" title="1">{
        path := internal.BuildCmdPath(site, "devmgr")

        // Build command request
        cmdReq := map[string]interface{}{
                "cmd": cmd,
                "mac": mac,
        }

        // Add additional parameters
        for k, v := range params </span><span class="cov8" title="1">{
                cmdReq[k] = v
        }</span>

        <span class="cov8" title="1">req := transport.NewRequest("POST", path).WithBody(cmdReq)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send command %s: %w", cmd, err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("command %s failed with status %d", cmd, resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package services

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "time"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/types"
        "github.com/unifi-go/gofi/websocket"
)

// eventService implements EventService.
type eventService struct {
        baseURL   string
        wsClient  *websocket.Client
        eventCh   chan types.Event
        errorCh   chan error
        closeCh   chan struct{}
        tlsConfig *tls.Config
}

// NewEventService creates a new event service.
func NewEventService(baseURL string, tlsConfig *tls.Config) EventService <span class="cov0" title="0">{
        return &amp;eventService{
                baseURL:   baseURL,
                tlsConfig: tlsConfig,
                eventCh:   make(chan types.Event, 100),
                errorCh:   make(chan error, 10),
                closeCh:   make(chan struct{}),
        }
}</span>

// Subscribe subscribes to events for a site.
func (e *eventService) Subscribe(ctx context.Context, site string) (&lt;-chan types.Event, &lt;-chan error, error) <span class="cov0" title="0">{
        // Build WebSocket URL
        wsPath := internal.BuildWebSocketPath(site)

        // Convert https:// to wss://
        wsURL := "wss" + e.baseURL[5:] + wsPath // Strip "https" and add "wss"

        // Create WebSocket client
        var opts []websocket.Option
        if e.tlsConfig != nil </span><span class="cov0" title="0">{
                opts = append(opts, websocket.WithTLSConfig(e.tlsConfig))
        }</span>

        <span class="cov0" title="0">client, err := websocket.New(wsURL, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create WebSocket client: %w", err)
        }</span>

        <span class="cov0" title="0">e.wsClient = client

        // Connect
        if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to connect: %w", err)
        }</span>

        // Start reading events
        <span class="cov0" title="0">go e.readLoop()

        return e.eventCh, e.errorCh, nil</span>
}

// readLoop reads events from the WebSocket.
func (e *eventService) readLoop() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                close(e.eventCh)
                close(e.errorCh)
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.closeCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        if e.wsClient == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">message, err := e.wsClient.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                select </span>{
                                case e.errorCh &lt;- fmt.Errorf("read error: %w", err):<span class="cov0" title="0"></span>
                                case &lt;-e.closeCh:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                                <span class="cov0" title="0">return</span>
                        }

                        // Parse event
                        <span class="cov0" title="0">var event types.Event
                        if err := json.Unmarshal(message, &amp;event); err != nil </span><span class="cov0" title="0">{
                                select </span>{
                                case e.errorCh &lt;- fmt.Errorf("parse error: %w", err):<span class="cov0" title="0"></span>
                                case &lt;-e.closeCh:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                                <span class="cov0" title="0">continue</span>
                        }

                        // Send event
                        <span class="cov0" title="0">select </span>{
                        case e.eventCh &lt;- event:<span class="cov0" title="0"></span>
                        case &lt;-e.closeCh:<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(1 * time.Second):<span class="cov0" title="0"></span>
                                // Drop event if channel is full
                        }
                }
        }
}

// Close closes the event stream.
func (e *eventService) Close() error <span class="cov0" title="0">{
        close(e.closeCh)

        if e.wsClient != nil </span><span class="cov0" title="0">{
                return e.wsClient.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// firewallService implements FirewallService.
type firewallService struct {
        transport transport.Transport
}

// NewFirewallService creates a new firewall service.
func NewFirewallService(transport transport.Transport) FirewallService <span class="cov8" title="1">{
        return &amp;firewallService{
                transport: transport,
        }
}</span>

// ListRules returns all firewall rules for a site.
func (s *firewallService) ListRules(ctx context.Context, site string) ([]types.FirewallRule, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "firewallrule", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list firewall rules: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list firewall rules failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.FirewallRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// GetRule returns a specific firewall rule by ID.
func (s *firewallService) GetRule(ctx context.Context, site, id string) (*types.FirewallRule, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "firewallrule", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get firewall rule: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("firewall rule not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get firewall rule failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.FirewallRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("firewall rule not found: %s", id)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// CreateRule creates a new firewall rule.
func (s *firewallService) CreateRule(ctx context.Context, site string, rule *types.FirewallRule) (*types.FirewallRule, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "firewallrule", "")
        req := transport.NewRequest("POST", path).WithBody(rule)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create firewall rule: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create firewall rule failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.FirewallRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create firewall rule returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// UpdateRule updates an existing firewall rule.
func (s *firewallService) UpdateRule(ctx context.Context, site string, rule *types.FirewallRule) (*types.FirewallRule, error) <span class="cov8" title="1">{
        if rule.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("firewall rule ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "firewallrule", rule.ID)
        req := transport.NewRequest("PUT", path).WithBody(rule)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update firewall rule: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update firewall rule failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.FirewallRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update firewall rule returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// DeleteRule deletes a firewall rule.
func (s *firewallService) DeleteRule(ctx context.Context, site, id string) error <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "firewallrule", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete firewall rule: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete firewall rule failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// EnableRule enables a firewall rule.
func (s *firewallService) EnableRule(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        rule, err := s.GetRule(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rule.Enabled = true
        _, err = s.UpdateRule(ctx, site, rule)
        return err</span>
}

// DisableRule disables a firewall rule.
func (s *firewallService) DisableRule(ctx context.Context, site, id string) error <span class="cov0" title="0">{
        rule, err := s.GetRule(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rule.Enabled = false
        _, err = s.UpdateRule(ctx, site, rule)
        return err</span>
}

// ReorderRules reorders firewall rules within a ruleset.
func (s *firewallService) ReorderRules(ctx context.Context, site, ruleset string, updates []types.FirewallRuleIndexUpdate) error <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "firewallrule", "reorder")
        req := transport.NewRequest("POST", path).WithBody(updates)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reorder firewall rules: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("reorder firewall rules failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListGroups returns all firewall groups for a site.
func (s *firewallService) ListGroups(ctx context.Context, site string) ([]types.FirewallGroup, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "firewallgroup", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list firewall groups: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list firewall groups failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.FirewallGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// GetGroup returns a specific firewall group by ID.
func (s *firewallService) GetGroup(ctx context.Context, site, id string) (*types.FirewallGroup, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "firewallgroup", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get firewall group: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("firewall group not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get firewall group failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.FirewallGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("firewall group not found: %s", id)
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// CreateGroup creates a new firewall group.
func (s *firewallService) CreateGroup(ctx context.Context, site string, group *types.FirewallGroup) (*types.FirewallGroup, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "firewallgroup", "")
        req := transport.NewRequest("POST", path).WithBody(group)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create firewall group: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create firewall group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.FirewallGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create firewall group returned empty response")
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// UpdateGroup updates an existing firewall group.
func (s *firewallService) UpdateGroup(ctx context.Context, site string, group *types.FirewallGroup) (*types.FirewallGroup, error) <span class="cov0" title="0">{
        if group.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("firewall group ID is required for update")
        }</span>

        <span class="cov0" title="0">path := internal.BuildRESTPath(site, "firewallgroup", group.ID)
        req := transport.NewRequest("PUT", path).WithBody(group)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update firewall group: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update firewall group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.FirewallGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update firewall group returned empty response")
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// DeleteGroup deletes a firewall group.
func (s *firewallService) DeleteGroup(ctx context.Context, site, id string) error <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "firewallgroup", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete firewall group: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete firewall group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListTrafficRules returns all traffic rules for a site.
func (s *firewallService) ListTrafficRules(ctx context.Context, site string) ([]types.TrafficRule, error) <span class="cov8" title="1">{
        path := internal.BuildV2APIPath(site, fmt.Sprintf("site/%s/trafficrule", site))
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list traffic rules: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list traffic rules failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.TrafficRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// GetTrafficRule returns a specific traffic rule by ID.
func (s *firewallService) GetTrafficRule(ctx context.Context, site, id string) (*types.TrafficRule, error) <span class="cov0" title="0">{
        path := internal.BuildV2APIPath(site, fmt.Sprintf("site/%s/trafficrule/%s", site, id))
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get traffic rule: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("traffic rule not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get traffic rule failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.TrafficRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("traffic rule not found: %s", id)
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// CreateTrafficRule creates a new traffic rule.
func (s *firewallService) CreateTrafficRule(ctx context.Context, site string, rule *types.TrafficRule) (*types.TrafficRule, error) <span class="cov8" title="1">{
        path := internal.BuildV2APIPath(site, fmt.Sprintf("site/%s/trafficrule", site))
        req := transport.NewRequest("POST", path).WithBody(rule)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create traffic rule: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create traffic rule failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.TrafficRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create traffic rule returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// UpdateTrafficRule updates an existing traffic rule.
func (s *firewallService) UpdateTrafficRule(ctx context.Context, site string, rule *types.TrafficRule) (*types.TrafficRule, error) <span class="cov0" title="0">{
        if rule.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("traffic rule ID is required for update")
        }</span>

        <span class="cov0" title="0">path := internal.BuildV2APIPath(site, fmt.Sprintf("site/%s/trafficrule/%s", site, rule.ID))
        req := transport.NewRequest("PUT", path).WithBody(rule)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update traffic rule: %w", err)
        }</span>

        // Note: v2 API returns 201 for PUT operations
        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 201 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update traffic rule failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.TrafficRule](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update traffic rule returned empty response")
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// DeleteTrafficRule deletes a traffic rule.
func (s *firewallService) DeleteTrafficRule(ctx context.Context, site, id string) error <span class="cov0" title="0">{
        path := internal.BuildV2APIPath(site, fmt.Sprintf("site/%s/trafficrule/%s", site, id))
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete traffic rule: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete traffic rule failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// networkService implements NetworkService.
type networkService struct {
        transport transport.Transport
}

// NewNetworkService creates a new network service.
func NewNetworkService(transport transport.Transport) NetworkService <span class="cov0" title="0">{
        return &amp;networkService{
                transport: transport,
        }
}</span>

// List returns all networks for a site.
func (s *networkService) List(ctx context.Context, site string) ([]types.Network, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "networkconf", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list networks: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list networks failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.Network](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return apiResp.Data, nil</span>
}

// Get returns a specific network by ID.
func (s *networkService) Get(ctx context.Context, site, id string) (*types.Network, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "networkconf", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get network: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get network failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">network, err := internal.ParseSingleResult[types.Network](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return network, nil</span>
}

// Create creates a new network.
func (s *networkService) Create(ctx context.Context, site string, network *types.Network) (*types.Network, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "networkconf", "")
        req := transport.NewRequest("POST", path).WithBody(network)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create network: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create network failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">created, err := internal.ParseSingleResult[types.Network](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return created, nil</span>
}

// Update updates a network.
func (s *networkService) Update(ctx context.Context, site string, network *types.Network) (*types.Network, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "networkconf", network.ID)
        req := transport.NewRequest("PUT", path).WithBody(network)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update network: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update network failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">updated, err := internal.ParseSingleResult[types.Network](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

// Delete deletes a network.
func (s *networkService) Delete(ctx context.Context, site, id string) error <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "networkconf", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete network: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete network failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// portForwardService implements PortForwardService.
type portForwardService struct {
        transport transport.Transport
}

// NewPortForwardService creates a new port forward service.
func NewPortForwardService(transport transport.Transport) PortForwardService <span class="cov8" title="1">{
        return &amp;portForwardService{
                transport: transport,
        }
}</span>

// List returns all port forwards.
func (s *portForwardService) List(ctx context.Context, site string) ([]types.PortForward, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portforward", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list port forwards: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list port forwards failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortForward](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a port forward by ID.
func (s *portForwardService) Get(ctx context.Context, site, id string) (*types.PortForward, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portforward", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get port forward: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov8" title="1">{
                if resp.StatusCode == 404 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("port forward not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get port forward failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortForward](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("port forward not found: %s", id)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Create creates a new port forward.
func (s *portForwardService) Create(ctx context.Context, site string, forward *types.PortForward) (*types.PortForward, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portforward", "")
        req := transport.NewRequest("POST", path).WithBody(forward)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create port forward: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create port forward failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortForward](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create port forward returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Update updates an existing port forward.
func (s *portForwardService) Update(ctx context.Context, site string, forward *types.PortForward) (*types.PortForward, error) <span class="cov8" title="1">{
        if forward.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("port forward ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "portforward", forward.ID)
        req := transport.NewRequest("PUT", path).WithBody(forward)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update port forward: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("port forward not found: %s", forward.ID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("update port forward failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortForward](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update port forward returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Delete deletes a port forward.
func (s *portForwardService) Delete(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portforward", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete port forward: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return fmt.Errorf("port forward not found: %s", id)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("delete port forward failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Enable enables a port forward.
func (s *portForwardService) Enable(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        forward, err := s.Get(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">forward.Enabled = true
        _, err = s.Update(ctx, site, forward)
        return err</span>
}

// Disable disables a port forward.
func (s *portForwardService) Disable(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        forward, err := s.Get(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">forward.Enabled = false
        _, err = s.Update(ctx, site, forward)
        return err</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// portProfileService implements PortProfileService.
type portProfileService struct {
        transport transport.Transport
}

// NewPortProfileService creates a new port profile service.
func NewPortProfileService(transport transport.Transport) PortProfileService <span class="cov8" title="1">{
        return &amp;portProfileService{
                transport: transport,
        }
}</span>

// List returns all port profiles.
func (s *portProfileService) List(ctx context.Context, site string) ([]types.PortProfile, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portconf", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list port profiles: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list port profiles failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a port profile by ID.
func (s *portProfileService) Get(ctx context.Context, site, id string) (*types.PortProfile, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portconf", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get port profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov8" title="1">{
                if resp.StatusCode == 404 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("port profile not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get port profile failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("port profile not found: %s", id)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Create creates a new port profile.
func (s *portProfileService) Create(ctx context.Context, site string, profile *types.PortProfile) (*types.PortProfile, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portconf", "")
        req := transport.NewRequest("POST", path).WithBody(profile)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create port profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create port profile failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create port profile returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Update updates an existing port profile.
func (s *portProfileService) Update(ctx context.Context, site string, profile *types.PortProfile) (*types.PortProfile, error) <span class="cov8" title="1">{
        if profile.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("port profile ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "portconf", profile.ID)
        req := transport.NewRequest("PUT", path).WithBody(profile)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update port profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("port profile not found: %s", profile.ID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("update port profile failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.PortProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update port profile returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Delete deletes a port profile.
func (s *portProfileService) Delete(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "portconf", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete port profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return fmt.Errorf("port profile not found: %s", id)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("delete port profile failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// routingService implements RoutingService.
type routingService struct {
        transport transport.Transport
}

// NewRoutingService creates a new routing service.
func NewRoutingService(transport transport.Transport) RoutingService <span class="cov8" title="1">{
        return &amp;routingService{
                transport: transport,
        }
}</span>

// List returns all routes.
func (s *routingService) List(ctx context.Context, site string) ([]types.Route, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "routing", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list routes: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list routes failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Route](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a route by ID.
func (s *routingService) Get(ctx context.Context, site, id string) (*types.Route, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "routing", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get route: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov8" title="1">{
                if resp.StatusCode == 404 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("route not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get route failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Route](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("route not found: %s", id)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Create creates a new route.
func (s *routingService) Create(ctx context.Context, site string, route *types.Route) (*types.Route, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "routing", "")
        req := transport.NewRequest("POST", path).WithBody(route)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create route: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create route failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Route](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create route returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Update updates an existing route.
func (s *routingService) Update(ctx context.Context, site string, route *types.Route) (*types.Route, error) <span class="cov8" title="1">{
        if route.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("route ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "routing", route.ID)
        req := transport.NewRequest("PUT", path).WithBody(route)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update route: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("route not found: %s", route.ID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("update route failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Route](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update route returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Delete deletes a route.
func (s *routingService) Delete(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "routing", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete route: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return fmt.Errorf("route not found: %s", id)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("delete route failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Enable enables a route.
func (s *routingService) Enable(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        route, err := s.Get(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">route.Enabled = true
        _, err = s.Update(ctx, site, route)
        return err</span>
}

// Disable disables a route.
func (s *routingService) Disable(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        route, err := s.Get(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">route.Enabled = false
        _, err = s.Update(ctx, site, route)
        return err</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package services

import (
        "context"

        "github.com/unifi-go/gofi/types"
)

// Placeholder service interfaces - will be implemented in later phases

// SiteService provides site management operations.
type SiteService interface {
        List(ctx context.Context) ([]types.Site, error)
        Get(ctx context.Context, id string) (*types.Site, error)
        Create(ctx context.Context, desc, name string) (*types.Site, error)
        Update(ctx context.Context, site *types.Site) (*types.Site, error)
        Delete(ctx context.Context, id string) error
        Health(ctx context.Context, site string) ([]types.HealthData, error)
        SysInfo(ctx context.Context, site string) (*types.SysInfo, error)
}

// DeviceService provides device control and configuration.
type DeviceService interface {
        List(ctx context.Context, site string) ([]types.Device, error)
        ListBasic(ctx context.Context, site string) ([]types.DeviceBasic, error)
        Get(ctx context.Context, site, id string) (*types.Device, error)
        GetByMAC(ctx context.Context, site, mac string) (*types.Device, error)
        Update(ctx context.Context, site string, device *types.Device) (*types.Device, error)
        Adopt(ctx context.Context, site, mac string) error
        Forget(ctx context.Context, site, mac string) error
        Restart(ctx context.Context, site, mac string) error
        ForceProvision(ctx context.Context, site, mac string) error
        Upgrade(ctx context.Context, site, mac string) error
        UpgradeExternal(ctx context.Context, site, mac, url string) error
        Locate(ctx context.Context, site, mac string) error
        Unlocate(ctx context.Context, site, mac string) error
        PowerCyclePort(ctx context.Context, site, switchMAC string, portIdx int) error
        SetLEDOverride(ctx context.Context, site, mac, mode string) error
        SpectrumScan(ctx context.Context, site, mac string) error
}

// NetworkService provides network and VLAN management.
type NetworkService interface {
        List(ctx context.Context, site string) ([]types.Network, error)
        Get(ctx context.Context, site, id string) (*types.Network, error)
        Create(ctx context.Context, site string, network *types.Network) (*types.Network, error)
        Update(ctx context.Context, site string, network *types.Network) (*types.Network, error)
        Delete(ctx context.Context, site, id string) error
}

// WLANService provides wireless network configuration.
type WLANService interface {
        // WLAN methods
        List(ctx context.Context, site string) ([]types.WLAN, error)
        Get(ctx context.Context, site, id string) (*types.WLAN, error)
        Create(ctx context.Context, site string, wlan *types.WLAN) (*types.WLAN, error)
        Update(ctx context.Context, site string, wlan *types.WLAN) (*types.WLAN, error)
        Delete(ctx context.Context, site, id string) error
        Enable(ctx context.Context, site, id string) error
        Disable(ctx context.Context, site, id string) error
        SetMACFilter(ctx context.Context, site, id, policy string, macs []string) error

        // WLAN Group methods
        ListGroups(ctx context.Context, site string) ([]types.WLANGroup, error)
        GetGroup(ctx context.Context, site, id string) (*types.WLANGroup, error)
        CreateGroup(ctx context.Context, site string, group *types.WLANGroup) (*types.WLANGroup, error)
        UpdateGroup(ctx context.Context, site string, group *types.WLANGroup) (*types.WLANGroup, error)
        DeleteGroup(ctx context.Context, site, id string) error
}

// FirewallService provides firewall rules and groups management.
type FirewallService interface {
        // Firewall Rule methods
        ListRules(ctx context.Context, site string) ([]types.FirewallRule, error)
        GetRule(ctx context.Context, site, id string) (*types.FirewallRule, error)
        CreateRule(ctx context.Context, site string, rule *types.FirewallRule) (*types.FirewallRule, error)
        UpdateRule(ctx context.Context, site string, rule *types.FirewallRule) (*types.FirewallRule, error)
        DeleteRule(ctx context.Context, site, id string) error
        EnableRule(ctx context.Context, site, id string) error
        DisableRule(ctx context.Context, site, id string) error
        ReorderRules(ctx context.Context, site, ruleset string, updates []types.FirewallRuleIndexUpdate) error

        // Firewall Group methods
        ListGroups(ctx context.Context, site string) ([]types.FirewallGroup, error)
        GetGroup(ctx context.Context, site, id string) (*types.FirewallGroup, error)
        CreateGroup(ctx context.Context, site string, group *types.FirewallGroup) (*types.FirewallGroup, error)
        UpdateGroup(ctx context.Context, site string, group *types.FirewallGroup) (*types.FirewallGroup, error)
        DeleteGroup(ctx context.Context, site, id string) error

        // Traffic Rule methods (v2 API)
        ListTrafficRules(ctx context.Context, site string) ([]types.TrafficRule, error)
        GetTrafficRule(ctx context.Context, site, id string) (*types.TrafficRule, error)
        CreateTrafficRule(ctx context.Context, site string, rule *types.TrafficRule) (*types.TrafficRule, error)
        UpdateTrafficRule(ctx context.Context, site string, rule *types.TrafficRule) (*types.TrafficRule, error)
        DeleteTrafficRule(ctx context.Context, site, id string) error
}

// ClientService provides connected client/station operations.
type ClientService interface {
        // ListActive returns all currently connected clients.
        ListActive(ctx context.Context, site string) ([]types.Client, error)

        // ListAll returns all known clients (including historical).
        ListAll(ctx context.Context, site string, opts ...ClientListOption) ([]types.Client, error)

        // Get returns a client by MAC address.
        Get(ctx context.Context, site, mac string) (*types.Client, error)

        // Block blocks a client from the network.
        Block(ctx context.Context, site, mac string) error

        // Unblock unblocks a previously blocked client.
        Unblock(ctx context.Context, site, mac string) error

        // Kick disconnects a client from the network.
        Kick(ctx context.Context, site, mac string) error

        // AuthorizeGuest authorizes a guest client.
        AuthorizeGuest(ctx context.Context, site, mac string, opts ...GuestAuthOption) error

        // UnauthorizeGuest revokes guest authorization.
        UnauthorizeGuest(ctx context.Context, site, mac string) error

        // Forget removes a client from the known clients list.
        Forget(ctx context.Context, site, mac string) error

        // SetFingerprint overrides the device fingerprint.
        SetFingerprint(ctx context.Context, site, mac string, devID int) error
}

// ClientListOption configures client list queries.
type ClientListOption func(*clientListOptions)

// clientListOptions holds options for listing clients.
type clientListOptions struct {
        withinHours int
}

// WithinHours limits results to clients seen within the specified hours.
func WithinHours(hours int) ClientListOption <span class="cov8" title="1">{
        return func(opts *clientListOptions) </span><span class="cov8" title="1">{
                opts.withinHours = hours
        }</span>
}

// GuestAuthOption configures guest authorization.
type GuestAuthOption func(*guestAuthOptions)

// guestAuthOptions holds options for guest authorization.
type guestAuthOptions struct {
        minutes int
        up      int
        down    int
        bytes   int
        apMAC   string
}

// WithDuration sets the authorization duration in minutes.
func WithDuration(minutes int) GuestAuthOption <span class="cov8" title="1">{
        return func(opts *guestAuthOptions) </span><span class="cov8" title="1">{
                opts.minutes = minutes
        }</span>
}

// WithUploadLimit sets the upload bandwidth limit in Kbps.
func WithUploadLimit(kbps int) GuestAuthOption <span class="cov8" title="1">{
        return func(opts *guestAuthOptions) </span><span class="cov8" title="1">{
                opts.up = kbps
        }</span>
}

// WithDownloadLimit sets the download bandwidth limit in Kbps.
func WithDownloadLimit(kbps int) GuestAuthOption <span class="cov8" title="1">{
        return func(opts *guestAuthOptions) </span><span class="cov8" title="1">{
                opts.down = kbps
        }</span>
}

// WithDataLimit sets the total data limit in megabytes.
func WithDataLimit(mb int) GuestAuthOption <span class="cov0" title="0">{
        return func(opts *guestAuthOptions) </span><span class="cov0" title="0">{
                opts.bytes = mb
        }</span>
}

// WithAPMAC restricts authorization to a specific AP.
func WithAPMAC(mac string) GuestAuthOption <span class="cov0" title="0">{
        return func(opts *guestAuthOptions) </span><span class="cov0" title="0">{
                opts.apMAC = mac
        }</span>
}

// UserService provides known client/user management.
type UserService interface {
        // User operations
        List(ctx context.Context, site string) ([]types.User, error)
        Get(ctx context.Context, site, id string) (*types.User, error)
        GetByMAC(ctx context.Context, site, mac string) (*types.User, error)
        Create(ctx context.Context, site string, user *types.User) (*types.User, error)
        Update(ctx context.Context, site string, user *types.User) (*types.User, error)
        Delete(ctx context.Context, site, id string) error
        DeleteByMAC(ctx context.Context, site, mac string) error
        SetFixedIP(ctx context.Context, site, mac, ip, networkID string) error
        ClearFixedIP(ctx context.Context, site, mac string) error

        // User group operations
        ListGroups(ctx context.Context, site string) ([]types.UserGroup, error)
        GetGroup(ctx context.Context, site, id string) (*types.UserGroup, error)
        CreateGroup(ctx context.Context, site string, group *types.UserGroup) (*types.UserGroup, error)
        UpdateGroup(ctx context.Context, site string, group *types.UserGroup) (*types.UserGroup, error)
        DeleteGroup(ctx context.Context, site, id string) error
}

// RoutingService provides static route management.
type RoutingService interface {
        List(ctx context.Context, site string) ([]types.Route, error)
        Get(ctx context.Context, site, id string) (*types.Route, error)
        Create(ctx context.Context, site string, route *types.Route) (*types.Route, error)
        Update(ctx context.Context, site string, route *types.Route) (*types.Route, error)
        Delete(ctx context.Context, site, id string) error
        Enable(ctx context.Context, site, id string) error
        Disable(ctx context.Context, site, id string) error
}

// PortForwardService provides port forwarding management.
type PortForwardService interface {
        List(ctx context.Context, site string) ([]types.PortForward, error)
        Get(ctx context.Context, site, id string) (*types.PortForward, error)
        Create(ctx context.Context, site string, forward *types.PortForward) (*types.PortForward, error)
        Update(ctx context.Context, site string, forward *types.PortForward) (*types.PortForward, error)
        Delete(ctx context.Context, site, id string) error
        Enable(ctx context.Context, site, id string) error
        Disable(ctx context.Context, site, id string) error
}

// PortProfileService provides port profile management.
type PortProfileService interface {
        List(ctx context.Context, site string) ([]types.PortProfile, error)
        Get(ctx context.Context, site, id string) (*types.PortProfile, error)
        Create(ctx context.Context, site string, profile *types.PortProfile) (*types.PortProfile, error)
        Update(ctx context.Context, site string, profile *types.PortProfile) (*types.PortProfile, error)
        Delete(ctx context.Context, site, id string) error
}

// SettingService provides system settings management.
type SettingService interface {
        Get(ctx context.Context, site, key string) (interface{}, error)
        Update(ctx context.Context, site string, setting interface{}) error

        // RADIUS profiles
        ListRadiusProfiles(ctx context.Context, site string) ([]types.RADIUSProfile, error)
        GetRadiusProfile(ctx context.Context, site, id string) (*types.RADIUSProfile, error)
        CreateRadiusProfile(ctx context.Context, site string, profile *types.RADIUSProfile) (*types.RADIUSProfile, error)
        UpdateRadiusProfile(ctx context.Context, site string, profile *types.RADIUSProfile) (*types.RADIUSProfile, error)
        DeleteRadiusProfile(ctx context.Context, site, id string) error

        // Dynamic DNS
        GetDynamicDNS(ctx context.Context, site string) (*types.DynamicDNS, error)
        UpdateDynamicDNS(ctx context.Context, site string, ddns *types.DynamicDNS) error
}

// SystemService provides system-level operations.
type SystemService interface {
        Status(ctx context.Context) (*types.Status, error)
        Self(ctx context.Context) (*types.AdminUser, error)
        Reboot(ctx context.Context) error
        SpeedTest(ctx context.Context, site string) error
        SpeedTestStatus(ctx context.Context, site string) (*types.SpeedTestStatus, error)
        ListBackups(ctx context.Context) ([]types.Backup, error)
        CreateBackup(ctx context.Context) error
        DeleteBackup(ctx context.Context, filename string) error
        ListAdmins(ctx context.Context) ([]types.AdminUser, error)
}

// EventService provides real-time event streaming.
type EventService interface {
        Subscribe(ctx context.Context, site string) (&lt;-chan types.Event, &lt;-chan error, error)
        Close() error
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// settingService implements SettingService.
type settingService struct {
        transport transport.Transport
}

// NewSettingService creates a new setting service.
func NewSettingService(transport transport.Transport) SettingService <span class="cov8" title="1">{
        return &amp;settingService{
                transport: transport,
        }
}</span>

// Get returns a setting by key.
func (s *settingService) Get(ctx context.Context, site, key string) (interface{}, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/proxy/network/api/s/%s/rest/setting/%s", site, key)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get setting: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("setting not found: %s", key)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get setting failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Setting](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting not found: %s", key)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Update updates a setting.
func (s *settingService) Update(ctx context.Context, site string, setting interface{}) error <span class="cov8" title="1">{
        // Extract key from setting (must be a types.Setting or compatible struct)
        var key string
        if set, ok := setting.(*types.Setting); ok </span><span class="cov8" title="1">{
                key = set.Key
        }</span> else<span class="cov0" title="0"> {
                // Try to get key via reflection or type assertion for typed settings
                return fmt.Errorf("invalid setting type")
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("/proxy/network/api/s/%s/rest/setting/%s", site, key)
        req := transport.NewRequest("PUT", path).WithBody(setting)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update setting: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("update setting failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListRadiusProfiles returns all RADIUS profiles.
func (s *settingService) ListRadiusProfiles(ctx context.Context, site string) ([]types.RADIUSProfile, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "radiusprofile", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list RADIUS profiles: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list RADIUS profiles failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.RADIUSProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// GetRadiusProfile returns a RADIUS profile by ID.
func (s *settingService) GetRadiusProfile(ctx context.Context, site, id string) (*types.RADIUSProfile, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "radiusprofile", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get RADIUS profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov8" title="1">{
                if resp.StatusCode == 404 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("RADIUS profile not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get RADIUS profile failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.RADIUSProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RADIUS profile not found: %s", id)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// CreateRadiusProfile creates a new RADIUS profile.
func (s *settingService) CreateRadiusProfile(ctx context.Context, site string, profile *types.RADIUSProfile) (*types.RADIUSProfile, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "radiusprofile", "")
        req := transport.NewRequest("POST", path).WithBody(profile)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create RADIUS profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create RADIUS profile failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.RADIUSProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create RADIUS profile returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// UpdateRadiusProfile updates an existing RADIUS profile.
func (s *settingService) UpdateRadiusProfile(ctx context.Context, site string, profile *types.RADIUSProfile) (*types.RADIUSProfile, error) <span class="cov8" title="1">{
        if profile.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RADIUS profile ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "radiusprofile", profile.ID)
        req := transport.NewRequest("PUT", path).WithBody(profile)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update RADIUS profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("RADIUS profile not found: %s", profile.ID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("update RADIUS profile failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.RADIUSProfile](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update RADIUS profile returned no data")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// DeleteRadiusProfile deletes a RADIUS profile.
func (s *settingService) DeleteRadiusProfile(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "radiusprofile", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete RADIUS profile: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return fmt.Errorf("RADIUS profile not found: %s", id)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("delete RADIUS profile failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetDynamicDNS returns the Dynamic DNS configuration.
func (s *settingService) GetDynamicDNS(ctx context.Context, site string) (*types.DynamicDNS, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "dynamicdns", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get Dynamic DNS: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get Dynamic DNS failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.DynamicDNS](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                // Not configured
                return nil, nil
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// UpdateDynamicDNS updates the Dynamic DNS configuration.
func (s *settingService) UpdateDynamicDNS(ctx context.Context, site string, ddns *types.DynamicDNS) error <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "dynamicdns", "")
        req := transport.NewRequest("PUT", path).WithBody(ddns)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update Dynamic DNS: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("update Dynamic DNS failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// siteService implements SiteService.
type siteService struct {
        transport transport.Transport
}

// NewSiteService creates a new site service.
func NewSiteService(transport transport.Transport) SiteService <span class="cov8" title="1">{
        return &amp;siteService{
                transport: transport,
        }
}</span>

// List returns all sites.
func (s *siteService) List(ctx context.Context) ([]types.Site, error) <span class="cov8" title="1">{
        req := transport.NewRequest("GET", "/api/self/sites")

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list sites: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list sites failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Site](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a specific site.
func (s *siteService) Get(ctx context.Context, id string) (*types.Site, error) <span class="cov8" title="1">{
        // List all sites and find the one we want
        sites, err := s.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, site := range sites </span><span class="cov8" title="1">{
                if site.ID == id || site.Name == id </span><span class="cov8" title="1">{
                        return &amp;site, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("site not found: %s", id)</span>
}

// Create creates a new site.
func (s *siteService) Create(ctx context.Context, desc, name string) (*types.Site, error) <span class="cov8" title="1">{
        createReq := types.CreateSiteRequest{
                Desc: desc,
                Name: name,
        }

        req := transport.NewRequest("POST", "/api/self/sites").
                WithBody(createReq)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create site: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create site failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">site, err := internal.ParseSingleResult[types.Site](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return site, nil</span>
}

// Update updates a site.
func (s *siteService) Update(ctx context.Context, site *types.Site) (*types.Site, error) <span class="cov0" title="0">{
        updateReq := types.UpdateSiteRequest{
                Desc: site.Desc,
                Name: site.Name,
        }

        path := fmt.Sprintf("/api/self/sites/%s", site.ID)
        req := transport.NewRequest("PUT", path).
                WithBody(updateReq)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update site: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update site failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">result, err := internal.ParseSingleResult[types.Site](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Delete deletes a site.
func (s *siteService) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        path := fmt.Sprintf("/api/self/sites/%s", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete site: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete site failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Health returns health information for a site.
func (s *siteService) Health(ctx context.Context, site string) ([]types.HealthData, error) <span class="cov8" title="1">{
        path := internal.BuildAPIPath(site, "stat/health")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get health: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get health failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.HealthData](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// SysInfo returns system information.
func (s *siteService) SysInfo(ctx context.Context, site string) (*types.SysInfo, error) <span class="cov8" title="1">{
        path := internal.BuildAPIPath(site, "stat/sysinfo")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sysinfo: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get sysinfo failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">sysInfo, err := internal.ParseSingleResult[types.SysInfo](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return sysInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// systemService implements SystemService.
type systemService struct {
        transport transport.Transport
}

// NewSystemService creates a new system service.
func NewSystemService(transport transport.Transport) SystemService <span class="cov8" title="1">{
        return &amp;systemService{
                transport: transport,
        }
}</span>

// Status returns the system status (non-authenticated endpoint).
func (s *systemService) Status(ctx context.Context) (*types.Status, error) <span class="cov8" title="1">{
        path := "/api/status"
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get status failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var status types.Status
        if err := resp.Parse(&amp;status); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;status, nil</span>
}

// Self returns the current user information.
func (s *systemService) Self(ctx context.Context) (*types.AdminUser, error) <span class="cov0" title="0">{
        path := "/api/self"
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get self: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get self failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.AdminUser](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user data returned")
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// Reboot reboots the controller.
func (s *systemService) Reboot(ctx context.Context) error <span class="cov8" title="1">{
        path := "/proxy/network/api/cmd/system"
        req := transport.NewRequest("POST", path).WithBody(map[string]string{
                "cmd": "reboot",
        })

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reboot: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("reboot failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SpeedTest initiates a speed test.
func (s *systemService) SpeedTest(ctx context.Context, site string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/proxy/network/api/s/%s/cmd/speedtest", site)
        req := transport.NewRequest("POST", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start speed test: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("speed test failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SpeedTestStatus returns the speed test status.
func (s *systemService) SpeedTestStatus(ctx context.Context, site string) (*types.SpeedTestStatus, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/proxy/network/api/s/%s/stat/speedtest", site)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get speed test status: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get speed test status failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.SpeedTestStatus](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                // No speed test run yet
                return nil, nil
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// ListBackups returns all backup files.
func (s *systemService) ListBackups(ctx context.Context) ([]types.Backup, error) <span class="cov8" title="1">{
        path := "/proxy/network/api/cmd/backup"
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list backups: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list backups failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.Backup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// CreateBackup creates a new backup.
func (s *systemService) CreateBackup(ctx context.Context) error <span class="cov8" title="1">{
        path := "/proxy/network/api/cmd/backup"
        req := transport.NewRequest("POST", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("create backup failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteBackup deletes a backup file.
func (s *systemService) DeleteBackup(ctx context.Context, filename string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/proxy/network/api/cmd/backup/%s", filename)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete backup: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete backup failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListAdmins returns all admin users.
func (s *systemService) ListAdmins(ctx context.Context) ([]types.AdminUser, error) <span class="cov8" title="1">{
        path := "/proxy/network/api/stat/admin"
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list admins: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list admins failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.AdminUser](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// userService implements UserService.
type userService struct {
        transport transport.Transport
}

// NewUserService creates a new user service.
func NewUserService(transport transport.Transport) UserService <span class="cov8" title="1">{
        return &amp;userService{
                transport: transport,
        }
}</span>

// List returns all known clients/users.
func (s *userService) List(ctx context.Context, site string) ([]types.User, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "user", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list users: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list users failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.User](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a user by ID.
func (s *userService) Get(ctx context.Context, site, id string) (*types.User, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "user", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get user failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.User](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found: %s", id)
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// GetByMAC returns a user by MAC address.
func (s *userService) GetByMAC(ctx context.Context, site, mac string) (*types.User, error) <span class="cov8" title="1">{
        // List all users and find by MAC
        users, err := s.List(ctx, site)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, user := range users </span><span class="cov8" title="1">{
                if user.MAC == mac </span><span class="cov8" title="1">{
                        return &amp;user, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("user not found with MAC: %s", mac)</span>
}

// Create creates a new user entry.
func (s *userService) Create(ctx context.Context, site string, user *types.User) (*types.User, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "user", "")
        req := transport.NewRequest("POST", path).WithBody(user)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create user failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.User](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create user returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Update updates an existing user.
func (s *userService) Update(ctx context.Context, site string, user *types.User) (*types.User, error) <span class="cov8" title="1">{
        if user.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "user", user.ID)
        req := transport.NewRequest("PUT", path).WithBody(user)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update user failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.User](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update user returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Delete deletes a user by ID.
func (s *userService) Delete(ctx context.Context, site, id string) error <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "user", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete user failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByMAC deletes a user by MAC address.
func (s *userService) DeleteByMAC(ctx context.Context, site, mac string) error <span class="cov0" title="0">{
        // Find user by MAC first
        user, err := s.GetByMAC(ctx, site, mac)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.Delete(ctx, site, user.ID)</span>
}

// SetFixedIP assigns a fixed IP to a user.
func (s *userService) SetFixedIP(ctx context.Context, site, mac, ip, networkID string) error <span class="cov8" title="1">{
        // Get user by MAC
        user, err := s.GetByMAC(ctx, site, mac)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update with fixed IP settings
        <span class="cov8" title="1">user.UseFixedIP = true
        user.FixedIP = ip
        user.NetworkID = networkID

        _, err = s.Update(ctx, site, user)
        return err</span>
}

// ClearFixedIP removes a fixed IP assignment.
func (s *userService) ClearFixedIP(ctx context.Context, site, mac string) error <span class="cov0" title="0">{
        // Get user by MAC
        user, err := s.GetByMAC(ctx, site, mac)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clear fixed IP settings
        <span class="cov0" title="0">user.UseFixedIP = false
        user.FixedIP = ""
        user.NetworkID = ""

        _, err = s.Update(ctx, site, user)
        return err</span>
}

// ListGroups returns all user groups.
func (s *userService) ListGroups(ctx context.Context, site string) ([]types.UserGroup, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "usergroup", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list user groups: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list user groups failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.UserGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// GetGroup returns a user group by ID.
func (s *userService) GetGroup(ctx context.Context, site, id string) (*types.UserGroup, error) <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "usergroup", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user group: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user group not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get user group failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.UserGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user group not found: %s", id)
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// CreateGroup creates a new user group.
func (s *userService) CreateGroup(ctx context.Context, site string, group *types.UserGroup) (*types.UserGroup, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "usergroup", "")
        req := transport.NewRequest("POST", path).WithBody(group)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user group: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create user group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.UserGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create user group returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// UpdateGroup updates an existing user group.
func (s *userService) UpdateGroup(ctx context.Context, site string, group *types.UserGroup) (*types.UserGroup, error) <span class="cov0" title="0">{
        if group.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user group ID is required for update")
        }</span>

        <span class="cov0" title="0">path := internal.BuildRESTPath(site, "usergroup", group.ID)
        req := transport.NewRequest("PUT", path).WithBody(group)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user group: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update user group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">apiResp, err := internal.ParseAPIResponse[types.UserGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update user group returned empty response")
        }</span>

        <span class="cov0" title="0">return &amp;apiResp.Data[0], nil</span>
}

// DeleteGroup deletes a user group.
func (s *userService) DeleteGroup(ctx context.Context, site, id string) error <span class="cov0" title="0">{
        path := internal.BuildRESTPath(site, "usergroup", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user group: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete user group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/unifi-go/gofi/internal"
        "github.com/unifi-go/gofi/transport"
        "github.com/unifi-go/gofi/types"
)

// wlanService implements WLANService.
type wlanService struct {
        transport transport.Transport
}

// NewWLANService creates a new WLAN service.
func NewWLANService(transport transport.Transport) WLANService <span class="cov8" title="1">{
        return &amp;wlanService{
                transport: transport,
        }
}</span>

// List returns all WLANs for a site.
func (s *wlanService) List(ctx context.Context, site string) ([]types.WLAN, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlanconf", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list WLANs: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list WLANs failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLAN](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// Get returns a specific WLAN by ID.
func (s *wlanService) Get(ctx context.Context, site, id string) (*types.WLAN, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlanconf", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get WLAN: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov8" title="1">{
                if resp.StatusCode == 404 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("WLAN not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get WLAN failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLAN](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WLAN not found: %s", id)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Create creates a new WLAN.
func (s *wlanService) Create(ctx context.Context, site string, wlan *types.WLAN) (*types.WLAN, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlanconf", "")
        req := transport.NewRequest("POST", path).WithBody(wlan)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create WLAN: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create WLAN failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLAN](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create WLAN returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Update updates an existing WLAN.
func (s *wlanService) Update(ctx context.Context, site string, wlan *types.WLAN) (*types.WLAN, error) <span class="cov8" title="1">{
        if wlan.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WLAN ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "wlanconf", wlan.ID)
        req := transport.NewRequest("PUT", path).WithBody(wlan)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update WLAN: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update WLAN failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLAN](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update WLAN returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// Delete deletes a WLAN.
func (s *wlanService) Delete(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlanconf", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete WLAN: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete WLAN failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Enable enables a WLAN.
func (s *wlanService) Enable(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        wlan, err := s.Get(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">wlan.Enabled = true
        _, err = s.Update(ctx, site, wlan)
        return err</span>
}

// Disable disables a WLAN.
func (s *wlanService) Disable(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        wlan, err := s.Get(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">wlan.Enabled = false
        _, err = s.Update(ctx, site, wlan)
        return err</span>
}

// SetMACFilter sets MAC filtering on a WLAN.
func (s *wlanService) SetMACFilter(ctx context.Context, site, id, policy string, macs []string) error <span class="cov8" title="1">{
        wlan, err := s.Get(ctx, site, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">wlan.MACFilterEnabled = true
        wlan.MACFilterPolicy = policy
        wlan.MACFilterList = macs

        _, err = s.Update(ctx, site, wlan)
        return err</span>
}

// ListGroups returns all WLAN groups for a site.
func (s *wlanService) ListGroups(ctx context.Context, site string) ([]types.WLANGroup, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlangroup", "")
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list WLAN groups: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list WLAN groups failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLANGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return apiResp.Data, nil</span>
}

// GetGroup returns a specific WLAN group by ID.
func (s *wlanService) GetGroup(ctx context.Context, site, id string) (*types.WLANGroup, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlangroup", id)
        req := transport.NewRequest("GET", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get WLAN group: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("WLAN group not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get WLAN group failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLANGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WLAN group not found: %s", id)
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// CreateGroup creates a new WLAN group.
func (s *wlanService) CreateGroup(ctx context.Context, site string, group *types.WLANGroup) (*types.WLANGroup, error) <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlangroup", "")
        req := transport.NewRequest("POST", path).WithBody(group)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create WLAN group: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create WLAN group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLANGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create WLAN group returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// UpdateGroup updates an existing WLAN group.
func (s *wlanService) UpdateGroup(ctx context.Context, site string, group *types.WLANGroup) (*types.WLANGroup, error) <span class="cov8" title="1">{
        if group.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WLAN group ID is required for update")
        }</span>

        <span class="cov8" title="1">path := internal.BuildRESTPath(site, "wlangroup", group.ID)
        req := transport.NewRequest("PUT", path).WithBody(group)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update WLAN group: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update WLAN group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">apiResp, err := internal.ParseAPIResponse[types.WLANGroup](resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(apiResp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update WLAN group returned empty response")
        }</span>

        <span class="cov8" title="1">return &amp;apiResp.Data[0], nil</span>
}

// DeleteGroup deletes a WLAN group.
func (s *wlanService) DeleteGroup(ctx context.Context, site, id string) error <span class="cov8" title="1">{
        path := internal.BuildRESTPath(site, "wlangroup", id)
        req := transport.NewRequest("DELETE", path)

        resp, err := s.transport.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete WLAN group: %w", err)
        }</span>

        <span class="cov8" title="1">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("delete WLAN group failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package transport

import (
        "crypto/tls"
        "time"
)

// Config holds transport layer configuration.
type Config struct {
        // BaseURL is the base URL of the UniFi controller.
        BaseURL string

        // Timeout is the request timeout.
        Timeout time.Duration

        // TLSConfig is the TLS configuration.
        TLSConfig *tls.Config

        // MaxIdleConns is the maximum number of idle connections.
        MaxIdleConns int

        // MaxConnsPerHost is the maximum number of connections per host.
        MaxConnsPerHost int

        // IdleConnTimeout is the idle connection timeout.
        IdleConnTimeout time.Duration

        // UserAgent is the User-Agent header value.
        UserAgent string
}

// Option is a functional option for configuring the transport.
type Option func(*Config)

// WithTimeout sets the request timeout.
func WithTimeout(timeout time.Duration) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Timeout = timeout
        }</span>
}

// WithTLSConfig sets the TLS configuration.
func WithTLSConfig(tlsConfig *tls.Config) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.TLSConfig = tlsConfig
        }</span>
}

// WithMaxIdleConns sets the maximum number of idle connections.
func WithMaxIdleConns(n int) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.MaxIdleConns = n
        }</span>
}

// WithUserAgent sets the User-Agent header.
func WithUserAgent(ua string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.UserAgent = ua
        }</span>
}

// DefaultConfig returns a Config with default values.
func DefaultConfig(baseURL string) *Config <span class="cov8" title="1">{
        return &amp;Config{
                BaseURL:          baseURL,
                Timeout:          30 * time.Second,
                MaxIdleConns:     10,
                MaxConnsPerHost:  10,
                IdleConnTimeout:  90 * time.Second,
                UserAgent:        "gofi/1.0",
        }
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package transport

// Request represents an HTTP request to be sent.
type Request struct {
        Method  string
        Path    string
        Body    interface{}
        Headers map[string]string
}

// NewRequest creates a new Request.
func NewRequest(method, path string) *Request <span class="cov8" title="1">{
        return &amp;Request{
                Method:  method,
                Path:    path,
                Headers: make(map[string]string),
        }
}</span>

// WithBody sets the request body.
func (r *Request) WithBody(body interface{}) *Request <span class="cov8" title="1">{
        r.Body = body
        return r
}</span>

// WithHeader sets a request header.
func (r *Request) WithHeader(key, value string) *Request <span class="cov8" title="1">{
        r.Headers[key] = value
        return r
}</span>

// WithHeaders sets multiple request headers.
func (r *Request) WithHeaders(headers map[string]string) *Request <span class="cov8" title="1">{
        for k, v := range headers </span><span class="cov8" title="1">{
                r.Headers[k] = v
        }</span>
        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package transport

import (
        "encoding/json"
        "fmt"
        "net/http"
)

// Response represents an HTTP response.
type Response struct {
        StatusCode int
        Body       []byte
        Headers    http.Header
}

// IsSuccess returns true if the response indicates success (2xx status code).
func (r *Response) IsSuccess() bool <span class="cov8" title="1">{
        return r.StatusCode &gt;= 200 &amp;&amp; r.StatusCode &lt; 300
}</span>

// Parse parses the response body into the given value.
func (r *Response) Parse(v interface{}) error <span class="cov8" title="1">{
        if len(r.Body) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(r.Body, v); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse response body: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// String returns the response body as a string.
func (r *Response) String() string <span class="cov8" title="1">{
        return string(r.Body)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package transport

import (
        "context"
        "fmt"
        "math"
        "time"
)

// RetryConfig configures retry behavior.
type RetryConfig struct {
        // MaxRetries is the maximum number of retry attempts.
        MaxRetries int

        // InitialBackoff is the initial backoff duration.
        InitialBackoff time.Duration

        // MaxBackoff is the maximum backoff duration.
        MaxBackoff time.Duration

        // Multiplier is the backoff multiplier.
        Multiplier float64

        // RetryableStatusCodes are HTTP status codes that should trigger a retry.
        RetryableStatusCodes []int
}

// DefaultRetryConfig returns a RetryConfig with sensible defaults.
func DefaultRetryConfig() *RetryConfig <span class="cov8" title="1">{
        return &amp;RetryConfig{
                MaxRetries:     3,
                InitialBackoff: 100 * time.Millisecond,
                MaxBackoff:     5 * time.Second,
                Multiplier:     2.0,
                RetryableStatusCodes: []int{
                        429, // Too Many Requests
                        500, // Internal Server Error
                        502, // Bad Gateway
                        503, // Service Unavailable
                        504, // Gateway Timeout
                },
        }
}</span>

// RetryTransport wraps a Transport with retry logic.
type RetryTransport struct {
        transport Transport
        config    *RetryConfig
}

// NewRetryTransport creates a new RetryTransport.
func NewRetryTransport(transport Transport, config *RetryConfig) *RetryTransport <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultRetryConfig()
        }</span>

        <span class="cov8" title="1">return &amp;RetryTransport{
                transport: transport,
                config:    config,
        }</span>
}

// Do executes a request with retry logic.
func (r *RetryTransport) Do(ctx context.Context, req *Request) (*Response, error) <span class="cov8" title="1">{
        var lastErr error
        var resp *Response

        for attempt := 0; attempt &lt;= r.config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                // Check if context is cancelled
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Execute request
                <span class="cov8" title="1">resp, lastErr = r.transport.Do(ctx, req)

                // If no error and successful response, return immediately
                if lastErr == nil &amp;&amp; !r.shouldRetry(resp) </span><span class="cov8" title="1">{
                        return resp, nil
                }</span>

                // Don't retry on last attempt
                <span class="cov8" title="1">if attempt == r.config.MaxRetries </span><span class="cov8" title="1">{
                        break</span>
                }

                // Calculate backoff
                <span class="cov8" title="1">backoff := r.calculateBackoff(attempt)

                // Wait before retry
                select </span>{
                case &lt;-time.After(backoff):<span class="cov8" title="1"></span>
                        // Continue to next attempt
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, ctx.Err()</span>
                }
        }

        // All retries exhausted
        <span class="cov8" title="1">if lastErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed after %d attempts: %w", r.config.MaxRetries+1, lastErr)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// shouldRetry determines if a response should trigger a retry.
func (r *RetryTransport) shouldRetry(resp *Response) bool <span class="cov8" title="1">{
        if resp == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">for _, code := range r.config.RetryableStatusCodes </span><span class="cov8" title="1">{
                if resp.StatusCode == code </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// calculateBackoff calculates the backoff duration for a given attempt.
func (r *RetryTransport) calculateBackoff(attempt int) time.Duration <span class="cov8" title="1">{
        backoff := float64(r.config.InitialBackoff) * math.Pow(r.config.Multiplier, float64(attempt))

        if backoff &gt; float64(r.config.MaxBackoff) </span><span class="cov8" title="1">{
                backoff = float64(r.config.MaxBackoff)
        }</span>

        <span class="cov8" title="1">return time.Duration(backoff)</span>
}

// SetCSRFToken sets the CSRF token on the underlying transport.
func (r *RetryTransport) SetCSRFToken(token string) <span class="cov8" title="1">{
        r.transport.SetCSRFToken(token)
}</span>

// GetCSRFToken returns the CSRF token from the underlying transport.
func (r *RetryTransport) GetCSRFToken() string <span class="cov8" title="1">{
        return r.transport.GetCSRFToken()
}</span>

// Close closes the underlying transport.
func (r *RetryTransport) Close() <span class="cov0" title="0">{
        r.transport.Close()
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package transport

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/http/cookiejar"
        "net/url"
        "sync/atomic"
)

// Transport represents an HTTP transport for making requests.
type Transport interface {
        // Do executes an HTTP request.
        Do(ctx context.Context, req *Request) (*Response, error)

        // SetCSRFToken sets the CSRF token for subsequent requests.
        SetCSRFToken(token string)

        // GetCSRFToken returns the current CSRF token.
        GetCSRFToken() string

        // Close closes any idle connections.
        Close()
}

// httpTransport implements the Transport interface.
type httpTransport struct {
        client    *http.Client
        baseURL   *url.URL
        csrfToken atomic.Value // stores string
        userAgent string
}

// New creates a new HTTP transport.
func New(config *Config, opts ...Option) (Transport, error) <span class="cov8" title="1">{
        // Apply options
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(config)
        }</span>

        // Parse base URL
        <span class="cov8" title="1">baseURL, err := url.Parse(config.BaseURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid base URL: %w", err)
        }</span>

        // Create cookie jar
        <span class="cov8" title="1">jar, err := cookiejar.New(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cookie jar: %w", err)
        }</span>

        // Create HTTP transport
        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig:     config.TLSConfig,
                MaxIdleConns:        config.MaxIdleConns,
                MaxConnsPerHost:     config.MaxConnsPerHost,
                IdleConnTimeout:     config.IdleConnTimeout,
                DisableCompression:  false,
                DisableKeepAlives:   false,
        }

        // If TLS config not provided but we need to skip verification
        if transport.TLSClientConfig == nil &amp;&amp; baseURL.Scheme == "https" </span><span class="cov8" title="1">{
                transport.TLSClientConfig = &amp;tls.Config{
                        InsecureSkipVerify: false, // Default to secure
                }
        }</span>

        // Create HTTP client
        <span class="cov8" title="1">client := &amp;http.Client{
                Transport: transport,
                Jar:       jar,
                Timeout:   config.Timeout,
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        // Don't follow redirects automatically
                        return http.ErrUseLastResponse
                }</span>,
        }

        <span class="cov8" title="1">t := &amp;httpTransport{
                client:    client,
                baseURL:   baseURL,
                userAgent: config.UserAgent,
        }

        // Initialize CSRF token as empty string
        t.csrfToken.Store("")

        return t, nil</span>
}

// Do executes an HTTP request.
func (t *httpTransport) Do(ctx context.Context, req *Request) (*Response, error) <span class="cov8" title="1">{
        // Build full URL
        fullURL, err := t.baseURL.Parse(req.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build URL: %w", err)
        }</span>

        // Serialize body if present
        <span class="cov8" title="1">var bodyReader io.Reader
        if req.Body != nil </span><span class="cov8" title="1">{
                bodyBytes, err := json.Marshal(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov8" title="1">bodyReader = bytes.NewReader(bodyBytes)</span>
        }

        // Create HTTP request
        <span class="cov8" title="1">httpReq, err := http.NewRequestWithContext(ctx, req.Method, fullURL.String(), bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set default headers
        <span class="cov8" title="1">httpReq.Header.Set("Accept", "application/json")
        if req.Body != nil </span><span class="cov8" title="1">{
                httpReq.Header.Set("Content-Type", "application/json")
        }</span>
        <span class="cov8" title="1">if t.userAgent != "" </span><span class="cov8" title="1">{
                httpReq.Header.Set("User-Agent", t.userAgent)
        }</span>

        // Add CSRF token if available
        <span class="cov8" title="1">if token := t.GetCSRFToken(); token != "" </span><span class="cov8" title="1">{
                httpReq.Header.Set("X-CSRF-Token", token)
        }</span>

        // Add custom headers
        <span class="cov8" title="1">for k, v := range req.Headers </span><span class="cov8" title="1">{
                httpReq.Header.Set(k, v)
        }</span>

        // Execute request
        <span class="cov8" title="1">httpResp, err := t.client.Do(httpReq)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer httpResp.Body.Close()

        // Read response body
        body, err := io.ReadAll(httpResp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Check for CSRF token in response headers
        <span class="cov8" title="1">if csrfToken := httpResp.Header.Get("X-CSRF-Token"); csrfToken != "" </span><span class="cov8" title="1">{
                t.SetCSRFToken(csrfToken)
        }</span>

        // Create response
        <span class="cov8" title="1">resp := &amp;Response{
                StatusCode: httpResp.StatusCode,
                Body:       body,
                Headers:    httpResp.Header,
        }

        return resp, nil</span>
}

// SetCSRFToken sets the CSRF token.
func (t *httpTransport) SetCSRFToken(token string) <span class="cov8" title="1">{
        t.csrfToken.Store(token)
}</span>

// GetCSRFToken returns the current CSRF token.
func (t *httpTransport) GetCSRFToken() string <span class="cov8" title="1">{
        if val := t.csrfToken.Load(); val != nil </span><span class="cov8" title="1">{
                if token, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return token
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Close closes any idle connections.
func (t *httpTransport) Close() <span class="cov8" title="1">{
        t.client.CloseIdleConnections()
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// APIResponse is a generic wrapper for UniFi API responses.
type APIResponse[T any] struct {
        Meta ResponseMeta `json:"meta"`
        Data []T          `json:"data"`
}

// ResponseMeta contains metadata about the API response.
type ResponseMeta struct {
        RC      string `json:"rc"`       // Response code ("ok" for success)
        Message string `json:"msg,omitempty"`
        Count   int    `json:"count,omitempty"`
}

// CommandRequest is a generic command request structure.
type CommandRequest struct {
        Cmd string `json:"cmd"`

        // Additional fields for various commands
        MAC      string `json:"mac,omitempty"`
        Duration int    `json:"duration,omitempty"`

        // For upgrades
        URL string `json:"url,omitempty"`

        // For LED override
        Mode string `json:"mode,omitempty"`

        // For port power cycle
        PortIdx int `json:"port_idx,omitempty"`

        // For guest authorization
        Minutes int    `json:"minutes,omitempty"`
        Up      int    `json:"up,omitempty"`   // Upload limit in kbps
        Down    int    `json:"down,omitempty"` // Download limit in kbps
        Bytes   int64  `json:"bytes,omitempty"` // Data transfer limit in bytes
        APMAC   string `json:"ap_mac,omitempty"`
}

// MAC represents a MAC address.
type MAC string

// Validate checks if the MAC address is valid.
func (m MAC) Validate() error <span class="cov8" title="1">{
        if m == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MAC address cannot be empty")
        }</span>

        // Normalize and validate format
        <span class="cov8" title="1">normalized := strings.ToLower(strings.ReplaceAll(string(m), ":", ""))
        normalized = strings.ReplaceAll(normalized, "-", "")

        if len(normalized) != 12 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid MAC address length: %s", m)
        }</span>

        // Check if hex
        <span class="cov8" title="1">matched, _ := regexp.MatchString("^[0-9a-f]{12}$", normalized)
        if !matched </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid MAC address format: %s", m)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// String returns the MAC address as a string.
func (m MAC) String() string <span class="cov8" title="1">{
        return string(m)
}</span>

// DeviceState represents the state of a device.
type DeviceState int

const (
        DeviceStateOffline      DeviceState = 0
        DeviceStateConnected    DeviceState = 1
        DeviceStatePending      DeviceState = 2
        DeviceStateDisconnected DeviceState = 3
        DeviceStateFirmware     DeviceState = 4
        DeviceStateProvisioning DeviceState = 5
        DeviceStateHeartbeat    DeviceState = 6
        DeviceStateAdopting     DeviceState = 7
        DeviceStateDeleting     DeviceState = 8
        DeviceStateInformed     DeviceState = 9
        DeviceStateUpgrading    DeviceState = 10
)

// String returns a string representation of the device state.
func (s DeviceState) String() string <span class="cov8" title="1">{
        switch s </span>{
        case DeviceStateOffline:<span class="cov8" title="1">
                return "offline"</span>
        case DeviceStateConnected:<span class="cov8" title="1">
                return "connected"</span>
        case DeviceStatePending:<span class="cov8" title="1">
                return "pending"</span>
        case DeviceStateDisconnected:<span class="cov8" title="1">
                return "disconnected"</span>
        case DeviceStateFirmware:<span class="cov8" title="1">
                return "firmware"</span>
        case DeviceStateProvisioning:<span class="cov8" title="1">
                return "provisioning"</span>
        case DeviceStateHeartbeat:<span class="cov8" title="1">
                return "heartbeat"</span>
        case DeviceStateAdopting:<span class="cov8" title="1">
                return "adopting"</span>
        case DeviceStateDeleting:<span class="cov8" title="1">
                return "deleting"</span>
        case DeviceStateInformed:<span class="cov8" title="1">
                return "informed"</span>
        case DeviceStateUpgrading:<span class="cov8" title="1">
                return "upgrading"</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("unknown(%d)", s)</span>
        }
}

// UnmarshalJSON implements json.Unmarshaler for DeviceState.
func (s *DeviceState) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var val int
        if err := json.Unmarshal(data, &amp;val); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*s = DeviceState(val)
        return nil</span>
}

// MarshalJSON implements json.Marshaler for DeviceState.
func (s DeviceState) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(int(s))
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "strconv"
)

// FlexInt handles JSON fields that may be either numbers or strings.
// UniFi API sometimes returns numbers as strings (e.g., "123" instead of 123).
type FlexInt struct {
        Val float64
        Txt string
}

// UnmarshalJSON implements json.Unmarshaler.
func (f *FlexInt) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Try to unmarshal as number first
        var num float64
        if err := json.Unmarshal(data, &amp;num); err == nil </span><span class="cov8" title="1">{
                f.Val = num
                f.Txt = fmt.Sprintf("%.0f", num)
                return nil
        }</span>

        // Try as string
        <span class="cov8" title="1">var str string
        if err := json.Unmarshal(data, &amp;str); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">f.Txt = str
        if str != "" </span><span class="cov8" title="1">{
                // Try to parse string as number
                if num, err := strconv.ParseFloat(str, 64); err == nil </span><span class="cov8" title="1">{
                        f.Val = num
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// MarshalJSON implements json.Marshaler.
func (f FlexInt) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Prefer numeric representation if we have a valid value
        if f.Val != 0 || f.Txt == "" || f.Txt == "0" </span><span class="cov8" title="1">{
                return json.Marshal(f.Val)
        }</span>
        <span class="cov0" title="0">return json.Marshal(f.Txt)</span>
}

// Int returns the value as an int.
func (f FlexInt) Int() int <span class="cov8" title="1">{
        return int(f.Val)
}</span>

// Int64 returns the value as an int64.
func (f FlexInt) Int64() int64 <span class="cov8" title="1">{
        return int64(f.Val)
}</span>

// Float64 returns the value as a float64.
func (f FlexInt) Float64() float64 <span class="cov8" title="1">{
        return f.Val
}</span>

// String returns the string representation.
func (f FlexInt) String() string <span class="cov0" title="0">{
        if f.Txt != "" </span><span class="cov0" title="0">{
                return f.Txt
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.0f", f.Val)</span>
}

// FlexBool handles JSON fields that may be booleans, strings, or numbers.
// UniFi API sometimes returns:
//   - true/false
//   - "true"/"false"
//   - 1/0
type FlexBool struct {
        Val bool
        Txt string
}

// UnmarshalJSON implements json.Unmarshaler.
func (f *FlexBool) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Try boolean first
        var b bool
        if err := json.Unmarshal(data, &amp;b); err == nil </span><span class="cov8" title="1">{
                f.Val = b
                f.Txt = strconv.FormatBool(b)
                return nil
        }</span>

        // Try string
        <span class="cov8" title="1">var str string
        if err := json.Unmarshal(data, &amp;str); err == nil </span><span class="cov8" title="1">{
                f.Txt = str
                f.Val = str == "true" || str == "1"
                return nil
        }</span>

        // Try number
        <span class="cov8" title="1">var num int
        if err := json.Unmarshal(data, &amp;num); err == nil </span><span class="cov8" title="1">{
                f.Val = num != 0
                f.Txt = strconv.FormatBool(f.Val)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("cannot unmarshal %s as FlexBool", string(data))</span>
}

// MarshalJSON implements json.Marshaler.
func (f FlexBool) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(f.Val)
}</span>

// Bool returns the boolean value.
func (f FlexBool) Bool() bool <span class="cov8" title="1">{
        return f.Val
}</span>

// String returns the string representation.
func (f FlexBool) String() string <span class="cov0" title="0">{
        return f.Txt
}</span>

// FlexString handles JSON fields that may be either a string or an array of strings.
type FlexString struct {
        Val string
        Arr []string
}

// UnmarshalJSON implements json.Unmarshaler.
func (f *FlexString) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Try string first
        var str string
        if err := json.Unmarshal(data, &amp;str); err == nil </span><span class="cov8" title="1">{
                f.Val = str
                f.Arr = []string{str}
                return nil
        }</span>

        // Try array
        <span class="cov8" title="1">var arr []string
        if err := json.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">f.Arr = arr
        if len(arr) &gt; 0 </span><span class="cov8" title="1">{
                f.Val = arr[0]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// MarshalJSON implements json.Marshaler.
func (f FlexString) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // If we have multiple values, marshal as array
        if len(f.Arr) &gt; 1 </span><span class="cov8" title="1">{
                return json.Marshal(f.Arr)
        }</span>
        // Otherwise marshal as string
        <span class="cov8" title="1">return json.Marshal(f.Val)</span>
}

// String returns the first string value.
func (f FlexString) String() string <span class="cov0" title="0">{
        return f.Val
}</span>

// Strings returns all string values.
func (f FlexString) Strings() []string <span class="cov0" title="0">{
        return f.Arr
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package websocket

import (
        "context"
        "crypto/tls"
        "fmt"
        "net/http"
        "net/url"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

// Client represents a WebSocket client.
type Client struct {
        url       string
        conn      *websocket.Conn
        mu        sync.RWMutex
        tlsConfig *tls.Config
        headers   http.Header
        dialer    *websocket.Dialer
}

// Config holds WebSocket client configuration.
type Config struct {
        TLSConfig *tls.Config
        Headers   http.Header
}

// Option configures a WebSocket client.
type Option func(*Config)

// WithTLSConfig sets the TLS configuration.
func WithTLSConfig(tlsConfig *tls.Config) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.TLSConfig = tlsConfig
        }</span>
}

// WithHeaders sets custom headers.
func WithHeaders(headers http.Header) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Headers = headers
        }</span>
}

// New creates a new WebSocket client.
func New(wsURL string, opts ...Option) (*Client, error) <span class="cov8" title="1">{
        // Parse URL to validate
        u, err := url.Parse(wsURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid WebSocket URL: %w", err)
        }</span>

        <span class="cov8" title="1">if u.Scheme != "ws" &amp;&amp; u.Scheme != "wss" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid WebSocket scheme: %s (must be ws or wss)", u.Scheme)
        }</span>

        <span class="cov8" title="1">config := &amp;Config{
                Headers: make(http.Header),
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(config)
        }</span>

        <span class="cov8" title="1">dialer := &amp;websocket.Dialer{
                HandshakeTimeout: 10 * time.Second,
                TLSClientConfig:  config.TLSConfig,
        }

        c := &amp;Client{
                url:       wsURL,
                headers:   config.Headers,
                tlsConfig: config.TLSConfig,
                dialer:    dialer,
        }

        return c, nil</span>
}

// Connect establishes the WebSocket connection.
func (c *Client) Connect(ctx context.Context) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.conn != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("already connected")
        }</span>

        <span class="cov8" title="1">conn, _, err := c.dialer.DialContext(ctx, c.url, c.headers)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect: %w", err)
        }</span>

        <span class="cov8" title="1">c.conn = conn
        return nil</span>
}

// Close closes the WebSocket connection.
func (c *Client) Close() error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.conn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">err := c.conn.Close()
        c.conn = nil
        return err</span>
}

// ReadMessage reads a message from the WebSocket.
func (c *Client) ReadMessage() ([]byte, error) <span class="cov8" title="1">{
        c.mu.RLock()
        conn := c.conn
        c.mu.RUnlock()

        if conn == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("not connected")
        }</span>

        <span class="cov8" title="1">_, message, err := conn.ReadMessage()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return message, nil</span>
}

// WriteMessage writes a message to the WebSocket.
func (c *Client) WriteMessage(data []byte) error <span class="cov8" title="1">{
        c.mu.RLock()
        conn := c.conn
        c.mu.RUnlock()

        if conn == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov8" title="1">return conn.WriteMessage(websocket.TextMessage, data)</span>
}

// IsConnected returns true if the WebSocket is connected.
func (c *Client) IsConnected() bool <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.conn != nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
